<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: pulse.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>pulse.c</h1><a href="pulse_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file pulse.c \brief Pulse/frequency generation function library. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'pulse.c'</span>
00005 <span class="comment">// Title        : Pulse/frequency generation function library</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2000-2002</span>
00007 <span class="comment">// Created      : 2002-08-19</span>
00008 <span class="comment">// Revised      : 2003-05-29</span>
00009 <span class="comment">// Version      : 0.7</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#ifndef WIN32</span>
00019 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;avr/io.h&gt;</span>
00020 <span class="preprocessor">    #include &lt;avr/signal.h&gt;</span>
00021 <span class="preprocessor">    #include &lt;avr/interrupt.h&gt;</span>
00022 <span class="preprocessor">    #include &lt;avr/pgmspace.h&gt;</span>
00023 <span class="preprocessor">#endif</span>
00024 <span class="preprocessor"></span>
00025 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00026 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00027 <span class="preprocessor">#include "<a class="code" href="pulse_8h.html">pulse.h</a>"</span>
00028 
00029 <span class="comment">// Global variables</span>
00030 <span class="comment">// pulse generation registers</span>
00031 <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  PulseT1AMode;
00032 <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> PulseT1ACount;
00033 <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> PulseT1APeriodTics;
00034 <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  PulseT1BMode;
00035 <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> PulseT1BCount;
00036 <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> PulseT1BPeriodTics;
00037 
00038 <span class="comment">// pulse mode bit definitions</span>
00039 <span class="comment">// PULSE_MODE_COUNTED</span>
00040 <span class="comment">//      if true, the requested number of pulses are output, then output is turned off</span>
00041 <span class="comment">//      if false, pulses are output continuously</span>
00042 <span class="preprocessor">#define PULSE_MODE_CONTINUOUS   0x00</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#define PULSE_MODE_COUNTED      0x01</span>
00044 <span class="preprocessor"></span>
00045 <span class="comment">// functions</span>
00046 
00047 <span class="keywordtype">void</span> pulseInit(<span class="keywordtype">void</span>)
00048 {
00049     <span class="comment">// initialize timer1 for pulse operation</span>
00050     pulseT1Init();
00051 }
00052 
00053 <span class="keywordtype">void</span> pulseT1Init(<span class="keywordtype">void</span>)
00054 {
00055     <span class="comment">// try to make sure that timer1 is in "normal" mode</span>
00056     <span class="comment">// most importantly, turn off PWM mode</span>
00057     <a class="code" href="group__timerpwm.html#ga2">timer1PWMOff</a>();
00058 
00059     <span class="comment">// set some reasonable initial values</span>
00060     <span class="comment">// in case the user forgets to</span>
00061     PulseT1AMode = 0;
00062     PulseT1BMode = 0;
00063     PulseT1ACount = 0;
00064     PulseT1BCount = 0;
00065     PulseT1APeriodTics = 0x8000;
00066     PulseT1BPeriodTics = 0x8000;
00067 
00068     <span class="comment">// attach the pulse service routines to</span>
00069     <span class="comment">// the timer 1 output compare A and B interrupts</span>
00070     <a class="code" href="group__timer.html#ga8">timerAttach</a>(TIMER1OUTCOMPAREA_INT,pulseT1AService);
00071     <a class="code" href="group__timer.html#ga8">timerAttach</a>(TIMER1OUTCOMPAREB_INT,pulseT1BService);
00072 }
00073 
00074 <span class="keywordtype">void</span> pulseT1Off(<span class="keywordtype">void</span>)
00075 {
00076     <span class="comment">// turns pulse outputs off immediately</span>
00077     
00078     <span class="comment">// set pulse counters to zero (finished)</span>
00079     PulseT1ACount = 0;
00080     PulseT1BCount = 0;
00081     <span class="comment">// disconnect OutputCompare action from OC1A pin</span>
00082     cbi(TCCR1A,COM1A1);
00083     cbi(TCCR1A,COM1A0);
00084     <span class="comment">// disconnect OutputCompare action from OC1B pin</span>
00085     cbi(TCCR1A,COM1B1);
00086     cbi(TCCR1A,COM1B0);
00087     <span class="comment">// detach the pulse service routines</span>
00088     <a class="code" href="group__timer.html#ga9">timerDetach</a>(TIMER1OUTCOMPAREA_INT);
00089     <a class="code" href="group__timer.html#ga9">timerDetach</a>(TIMER1OUTCOMPAREB_INT);
00090 }
00091 
00092 <span class="keywordtype">void</span> pulseT1ASetFreq(u16 freqHz)
00093 {
00094     <span class="comment">// set the frequency of the pulse output</span>
00095     <span class="comment">// we need to find the requested period/2 (in timer tics)</span>
00096     <span class="comment">// from the frequency (in hertz)</span>
00097 
00098     <span class="comment">// calculate how many tics in period/2</span>
00099     <span class="comment">// this is the (timer tic rate)/(2*requested freq)</span>
00100     PulseT1APeriodTics = ((u32)F_CPU/((u32)<a class="code" href="group__timer.html#ga7">timer1GetPrescaler</a>()*2*freqHz));
00101 }
00102 
00103 <span class="keywordtype">void</span> pulseT1BSetFreq(u16 freqHz)
00104 {
00105     <span class="comment">// set the frequency of the pulse output</span>
00106     <span class="comment">// we need to find the requested period/2 (in timer tics)</span>
00107     <span class="comment">// from the frequency (in hertz)</span>
00108 
00109     <span class="comment">// calculate how many tics in period/2</span>
00110     <span class="comment">// this is the (timer tic rate)/(2*requested freq)</span>
00111     PulseT1BPeriodTics = ((u32)F_CPU/((u32)<a class="code" href="group__timer.html#ga7">timer1GetPrescaler</a>()*2*freqHz));
00112 }
00113 
00114 <span class="keywordtype">void</span> pulseT1ARun(u16 nPulses)
00115 {
00116     <span class="comment">// set the number of pulses we want and the mode</span>
00117     <span class="keywordflow">if</span>(nPulses)
00118     {
00119         <span class="comment">// if the nPulses is non-zero, use "counted" mode</span>
00120         PulseT1AMode |= PULSE_MODE_COUNTED;
00121         PulseT1ACount = nPulses&lt;&lt;1;
00122     }
00123     <span class="keywordflow">else</span>
00124     {
00125         <span class="comment">// if nPulses is zero, run forever</span>
00126         PulseT1AMode &amp;= ~PULSE_MODE_COUNTED;
00127         PulseT1ACount = 1&lt;&lt;1;
00128     }
00129     <span class="comment">// set OutputCompare action to toggle OC1A pin</span>
00130     cbi(TCCR1A,COM1A1);
00131     sbi(TCCR1A,COM1A0);
00132 
00133     <span class="comment">// now the "enabling" stuff</span>
00134 
00135     <span class="comment">// set the output compare one pulse cycle ahead of current timer position </span>
00136     <span class="comment">// to make sure we don't have to wait until the timer overflows and comes</span>
00137     <span class="comment">// back to the current value</span>
00138     <span class="comment">// set future output compare time to TCNT1 + PulseT1APeriodTics</span>
00139     <span class="comment">//outw(OCR1A, inw(TCNT1) + PulseT1APeriodTics);</span>
00140     OCR1A += PulseT1APeriodTics;
00141 
00142     <span class="comment">// enable OutputCompare interrupt</span>
00143     sbi(TIMSK, OCIE1A);
00144 }
00145 
00146 <span class="keywordtype">void</span> pulseT1BRun(u16 nPulses)
00147 {
00148     <span class="comment">// set the number of pulses we want and the mode</span>
00149     <span class="keywordflow">if</span>(nPulses)
00150     {
00151         <span class="comment">// if the nPulses is non-zero, use "counted" mode</span>
00152         PulseT1BMode |= PULSE_MODE_COUNTED;
00153         PulseT1BCount = nPulses&lt;&lt;1;
00154     }
00155     <span class="keywordflow">else</span>
00156     {
00157         <span class="comment">// if nPulses is zero, run forever</span>
00158         PulseT1BMode &amp;= ~PULSE_MODE_COUNTED;
00159         PulseT1BCount = 1&lt;&lt;1;
00160     }
00161     <span class="comment">// set OutputCompare action to toggle OC1B pin</span>
00162     <span class="comment">// (note: with all the A's and B's flying around, TCCR1A is not a bug)</span>
00163     cbi(TCCR1A,COM1B1);
00164     sbi(TCCR1A,COM1B0);
00165 
00166     <span class="comment">// now the "enabling" stuff</span>
00167 
00168     <span class="comment">// set the output compare one pulse cycle ahead of current timer position </span>
00169     <span class="comment">// to make sure we don't have to wait until the timer overflows and comes</span>
00170     <span class="comment">// back to the current value</span>
00171     <span class="comment">// set future output compare time to TCNT1 + PulseT1APeriodTics</span>
00172     <span class="comment">//outw(OCR1B, inw(TCNT1) + PulseT1BPeriodTics);</span>
00173     OCR1B += PulseT1BPeriodTics;
00174 
00175     <span class="comment">// enable OutputCompare interrupt</span>
00176     sbi(TIMSK, OCIE1B);
00177 }
00178 
00179 <span class="keywordtype">void</span> pulseT1AStop(<span class="keywordtype">void</span>)
00180 {
00181     <span class="comment">// stop output regardless of remaining pulses or mode</span>
00182     <span class="comment">// go to "counted" mode</span>
00183     PulseT1AMode |= PULSE_MODE_COUNTED;
00184     <span class="comment">// set pulses to zero</span>
00185     PulseT1ACount = 0;
00186 }
00187 
00188 <span class="keywordtype">void</span> pulseT1BStop(<span class="keywordtype">void</span>)
00189 {
00190     <span class="comment">// stop output regardless of remaining pulses or mode</span>
00191     <span class="comment">// go to "counted" mode</span>
00192     PulseT1BMode |= PULSE_MODE_COUNTED;
00193     <span class="comment">// set pulses to zero</span>
00194     PulseT1BCount = 0;
00195 }
00196 
00197 u16 pulseT1ARemaining(<span class="keywordtype">void</span>)
00198 {
00199     <span class="comment">// return the number of pulses remaining for channel A</span>
00200     <span class="comment">// add 1 to make sure we round up, &gt;&gt;1 equivalent to /2</span>
00201     <span class="keywordflow">return</span> (PulseT1ACount+1)&gt;&gt;1;
00202 }
00203 
00204 u16 pulseT1BRemaining(<span class="keywordtype">void</span>)
00205 {
00206     <span class="comment">// return the number of pulses remaining for channel A</span>
00207     <span class="comment">// add 1 to make sure we round up, &gt;&gt;1 equivalent to /2</span>
00208     <span class="keywordflow">return</span> (PulseT1BCount+1)&gt;&gt;1;
00209 }
00210 
00211 <span class="keywordtype">void</span> pulseT1AService(<span class="keywordtype">void</span>)
00212 {
00213     <span class="comment">// check if TimerPulseACount is non-zero</span>
00214     <span class="comment">//      (i.e. pulses are still requested)</span>
00215     <span class="keywordflow">if</span>(PulseT1ACount)
00216     {
00217         <span class="comment">//u16 OCValue;</span>
00218         <span class="comment">// read in current value of output compare register OCR1A</span>
00219         <span class="comment">//OCValue =  inp(OCR1AL);       // read low byte of OCR1A</span>
00220         <span class="comment">//OCValue += inp(OCR1AH)&lt;&lt;8;    // read high byte of OCR1A</span>
00221         <span class="comment">// increment OCR1A value by PulseT1APeriodTics</span>
00222         <span class="comment">//OCValue += PulseT1APeriodTics;</span>
00223         <span class="comment">// set future output compare time to this new value</span>
00224         <span class="comment">//outp((OCValue&gt;&gt;8),        OCR1AH);    // write high byte</span>
00225         <span class="comment">//outp((OCValue &amp; 0x00FF),OCR1AL);  // write low byte</span>
00226 
00227         <span class="comment">// the following line should be identical in operation</span>
00228         <span class="comment">// to the lines above, but for the moment, I'm not convinced</span>
00229         <span class="comment">// this method is bug-free.  At least it's simpler!</span>
00230         <span class="comment">//outw(OCR1A, inw(OCR1A) + PulseT1APeriodTics);</span>
00231         <span class="comment">// change again</span>
00232         OCR1A += PulseT1APeriodTics;
00233                         
00234         <span class="comment">// decrement the number of pulses executed</span>
00235         <span class="keywordflow">if</span>(PulseT1AMode &amp; PULSE_MODE_COUNTED)
00236             PulseT1ACount--;
00237     }
00238     <span class="keywordflow">else</span>
00239     {
00240         <span class="comment">// pulse count has reached zero</span>
00241         <span class="comment">// disable the output compare's action on OC1A pin</span>
00242         cbi(TCCR1A,COM1A1);
00243         cbi(TCCR1A,COM1A0);
00244         <span class="comment">// and disable the output compare's interrupt to stop pulsing</span>
00245         cbi(TIMSK, OCIE1A);
00246     }
00247 }
00248 
00249 <span class="keywordtype">void</span> pulseT1BService(<span class="keywordtype">void</span>)
00250 {
00251     <span class="comment">// check if TimerPulseACount is non-zero</span>
00252     <span class="comment">//      (i.e. pulses are still requested)</span>
00253     <span class="keywordflow">if</span>(PulseT1BCount)
00254     {
00255         <span class="comment">//u16 OCValue;</span>
00256         <span class="comment">// read in current value of output compare register OCR1B</span>
00257         <span class="comment">//OCValue =  inp(OCR1BL);       // read low byte of OCR1B</span>
00258         <span class="comment">//OCValue += inp(OCR1BH)&lt;&lt;8;    // read high byte of OCR1B</span>
00259         <span class="comment">// increment OCR1B value by PulseT1BPeriodTics</span>
00260         <span class="comment">//OCValue += PulseT1BPeriodTics; </span>
00261         <span class="comment">// set future output compare time to this new value</span>
00262         <span class="comment">//outp((OCValue&gt;&gt;8),        OCR1BH);    // write high byte</span>
00263         <span class="comment">//outp((OCValue &amp; 0x00FF),OCR1BL);  // write low byte</span>
00264 
00265         <span class="comment">// the following line should be identical in operation</span>
00266         <span class="comment">// to the lines above, but for the moment, I'm not convinced</span>
00267         <span class="comment">// this method is bug-free.  At least it's simpler!</span>
00268         <span class="comment">//outw(OCR1B, inw(OCR1B) + PulseT1BPeriodTics);</span>
00269         <span class="comment">// change again</span>
00270         OCR1B += PulseT1BPeriodTics;
00271 
00272         
00273         <span class="comment">// decrement the number of pulses executed</span>
00274         <span class="keywordflow">if</span>(PulseT1BMode &amp; PULSE_MODE_COUNTED)
00275             PulseT1BCount--;
00276     }
00277     <span class="keywordflow">else</span>
00278     {
00279         <span class="comment">// pulse count has reached zero</span>
00280         <span class="comment">// disable the output compare's action on OC1B pin</span>
00281         cbi(TCCR1A,COM1B1);
00282         cbi(TCCR1A,COM1B0);
00283         <span class="comment">// and disable the output compare's interrupt to stop pulsing</span>
00284         cbi(TIMSK, OCIE1B);
00285     }
00286 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Aug 22 04:29:28 2005 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
