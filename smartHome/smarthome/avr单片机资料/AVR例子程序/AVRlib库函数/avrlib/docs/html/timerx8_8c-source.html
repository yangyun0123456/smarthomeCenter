<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: timerx8.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>timerx8.c</h1><a href="timerx8_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file timerx8.c \brief Timer function library for ATmegaXX8 Processors. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'timerx8.c'</span>
00005 <span class="comment">// Title        : Timer function library for ATmegaXX8 Processors</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2000-2005</span>
00007 <span class="comment">// Created      : 11/22/2000</span>
00008 <span class="comment">// Revised      : 06/15/2005</span>
00009 <span class="comment">// Version      : 1.0</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>
00019 <span class="preprocessor">#include &lt;avr/signal.h&gt;</span>
00020 <span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>
00021 <span class="preprocessor">#include &lt;avr/pgmspace.h&gt;</span>
00022 <span class="preprocessor">#include &lt;avr/sleep.h&gt;</span>
00023 
00024 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00025 <span class="preprocessor">#include "<a class="code" href="timerx8_8h.html">timerx8.h</a>"</span>
00026 
00027 <span class="comment">// Program ROM constants</span>
00028 <span class="comment">// the prescale division values stored in order of timer control register index</span>
00029 <span class="comment">// STOP, CLK, CLK/8, CLK/64, CLK/256, CLK/1024</span>
00030 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> __attribute__ ((progmem)) TimerPrescaleFactor[] = {0,1,8,64,256,1024};
00031 <span class="comment">// the prescale division values stored in order of timer control register index</span>
00032 <span class="comment">// STOP, CLK, CLK/8, CLK/32, CLK/64, CLK/128, CLK/256, CLK/1024</span>
00033 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> __attribute__ ((progmem)) TimerRTCPrescaleFactor[] = {0,1,8,32,64,128,256,1024};
00034 
00035 <span class="comment">// Global variables</span>
00036 <span class="comment">// time registers</span>
00037 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> TimerPauseReg;
00038 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer0Reg0;
00039 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer2Reg0;
00040 
00041 <span class="keyword">typedef</span> void (*voidFuncPtr)(void);
00042 <span class="keyword">volatile</span> <span class="keyword">static</span> voidFuncPtr TimerIntFunc[TIMER_NUM_INTERRUPTS];
00043 
00044 <span class="comment">// delay for a minimum of &lt;us&gt; microseconds </span>
00045 <span class="comment">// the time resolution is dependent on the time the loop takes </span>
00046 <span class="comment">// e.g. with 4Mhz and 5 cycles per loop, the resolution is 1.25 us </span>
00047 <span class="keywordtype">void</span> delay_us(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> time_us) 
00048 {
00049     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> delay_loops;
00050     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i;
00051 
00052     delay_loops = (time_us+3)/5*CYCLES_PER_US; <span class="comment">// +3 for rounding up (dirty) </span>
00053 
00054     <span class="comment">// one loop takes 5 cpu cycles </span>
00055     <span class="keywordflow">for</span> (i=0; i &lt; delay_loops; i++) {};
00056 }
00057 <span class="comment">/*</span>
00058 <span class="comment">void delay_ms(unsigned char time_ms)</span>
00059 <span class="comment">{</span>
00060 <span class="comment">    unsigned short delay_count = F_CPU / 4000;</span>
00061 <span class="comment"></span>
00062 <span class="comment">    unsigned short cnt;</span>
00063 <span class="comment">    asm volatile ("\n"</span>
00064 <span class="comment">                  "L_dl1%=:\n\t"</span>
00065 <span class="comment">                  "mov %A0, %A2\n\t"</span>
00066 <span class="comment">                  "mov %B0, %B2\n"</span>
00067 <span class="comment">                  "L_dl2%=:\n\t"</span>
00068 <span class="comment">                  "sbiw %A0, 1\n\t"</span>
00069 <span class="comment">                  "brne L_dl2%=\n\t"</span>
00070 <span class="comment">                  "dec %1\n\t" "brne L_dl1%=\n\t":"=&amp;w" (cnt)</span>
00071 <span class="comment">                  :"r"(time_ms), "r"((unsigned short) (delay_count))</span>
00072 <span class="comment">    );</span>
00073 <span class="comment">}</span>
00074 <span class="comment">*/</span>
<a name="l00075"></a><a class="code" href="group__timer.html#ga1">00075</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga1">timerInit</a>(<span class="keywordtype">void</span>)
00076 {
00077     u08 intNum;
00078     <span class="comment">// detach all user functions from interrupts</span>
00079     <span class="keywordflow">for</span>(intNum=0; intNum&lt;TIMER_NUM_INTERRUPTS; intNum++)
00080         <a class="code" href="group__timer.html#ga9">timerDetach</a>(intNum);
00081 
00082     <span class="comment">// initialize all timers</span>
00083     <a class="code" href="group__timer.html#ga2">timer0Init</a>();
00084     <a class="code" href="group__timer.html#ga3">timer1Init</a>();
00085 <span class="preprocessor">    #ifdef TCNT2    // support timer2 only if it exists</span>
00086 <span class="preprocessor"></span>    timer2Init();
00087 <span class="preprocessor">    #endif</span>
00088 <span class="preprocessor"></span>    <span class="comment">// enable interrupts</span>
00089     sei();
00090 }
00091 
<a name="l00092"></a><a class="code" href="group__timer.html#ga2">00092</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga2">timer0Init</a>()
00093 {
00094     <span class="comment">// initialize timer 0</span>
00095     <a class="code" href="group__timer.html#ga4">timer0SetPrescaler</a>( <a class="code" href="group__timer.html#ga33">TIMER0PRESCALE</a> );   <span class="comment">// set prescaler</span>
00096     TCNT0 = 0;                              <span class="comment">// reset TCNT0</span>
00097     sbi(TIMSK0, TOIE0);                     <span class="comment">// enable TCNT0 overflow interrupt</span>
00098 
00099     <a class="code" href="group__timer.html#ga11">timer0ClearOverflowCount</a>();             <span class="comment">// initialize time registers</span>
00100 }
00101 
<a name="l00102"></a><a class="code" href="group__timer.html#ga3">00102</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga3">timer1Init</a>(<span class="keywordtype">void</span>)
00103 {
00104     <span class="comment">// initialize timer 1</span>
00105     <a class="code" href="group__timer.html#ga6">timer1SetPrescaler</a>( <a class="code" href="group__timer.html#ga34">TIMER1PRESCALE</a> );   <span class="comment">// set prescaler</span>
00106     TCNT1 = 0;                              <span class="comment">// reset TCNT1</span>
00107     sbi(TIMSK1, TOIE1);                     <span class="comment">// enable TCNT1 overflow</span>
00108 }
00109 
00110 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00111 <span class="preprocessor"></span><span class="keywordtype">void</span> timer2Init(<span class="keywordtype">void</span>)
00112 {
00113     <span class="comment">// initialize timer 2</span>
00114     <a class="code" href="group__timer128.html#ga8">timer2SetPrescaler</a>( <a class="code" href="group__timer.html#ga35">TIMER2PRESCALE</a> );   <span class="comment">// set prescaler</span>
00115     TCNT2 = 0;                              <span class="comment">// reset TCNT2</span>
00116     sbi(TIMSK2, TOIE2);                     <span class="comment">// enable TCNT2 overflow</span>
00117 
00118     timer2ClearOverflowCount();             <span class="comment">// initialize time registers</span>
00119 }
00120 <span class="preprocessor">#endif</span>
00121 <span class="preprocessor"></span>
<a name="l00122"></a><a class="code" href="group__timer.html#ga4">00122</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga4">timer0SetPrescaler</a>(u08 prescale)
00123 {
00124     <span class="comment">// set prescaler on timer 0</span>
00125     TCCR0B = ((TCCR0B &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00126 }
00127 
<a name="l00128"></a><a class="code" href="group__timer.html#ga6">00128</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga6">timer1SetPrescaler</a>(u08 prescale)
00129 {
00130     <span class="comment">// set prescaler on timer 1</span>
00131     TCCR1B = ((TCCR1B &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00132 }
00133 
00134 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00135 <span class="preprocessor"></span><span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga8">timer2SetPrescaler</a>(u08 prescale)
00136 {
00137     <span class="comment">// set prescaler on timer 2</span>
00138     TCCR2B = ((TCCR2B &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00139 }
00140 <span class="preprocessor">#endif</span>
00141 <span class="preprocessor"></span>
<a name="l00142"></a><a class="code" href="group__timer.html#ga5">00142</a> u16 <a class="code" href="group__timer.html#ga5">timer0GetPrescaler</a>(<span class="keywordtype">void</span>)
00143 {
00144     <span class="comment">// get the current prescaler setting</span>
00145     <span class="keywordflow">return</span> (pgm_read_word(TimerPrescaleFactor+(TCCR0B &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00146 }
00147 
<a name="l00148"></a><a class="code" href="group__timer.html#ga7">00148</a> u16 <a class="code" href="group__timer.html#ga7">timer1GetPrescaler</a>(<span class="keywordtype">void</span>)
00149 {
00150     <span class="comment">// get the current prescaler setting</span>
00151     <span class="keywordflow">return</span> (pgm_read_word(TimerPrescaleFactor+(TCCR1B &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00152 }
00153 
00154 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00155 <span class="preprocessor"></span>u16 <a class="code" href="group__timer128.html#ga12">timer2GetPrescaler</a>(<span class="keywordtype">void</span>)
00156 {
00157     <span class="comment">//TODO: can we assume for all 3-timer AVR processors,</span>
00158     <span class="comment">// that timer2 is the RTC timer?</span>
00159 
00160     <span class="comment">// get the current prescaler setting</span>
00161     <span class="keywordflow">return</span> (pgm_read_word(TimerRTCPrescaleFactor+(TCCR2B &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00162 }
00163 <span class="preprocessor">#endif</span>
00164 <span class="preprocessor"></span>
<a name="l00165"></a><a class="code" href="group__timer.html#ga8">00165</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga8">timerAttach</a>(u08 interruptNum, <span class="keywordtype">void</span> (*userFunc)(<span class="keywordtype">void</span>) )
00166 {
00167     <span class="comment">// make sure the interrupt number is within bounds</span>
00168     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00169     {
00170         <span class="comment">// set the interrupt function to run</span>
00171         <span class="comment">// the supplied user's function</span>
00172         TimerIntFunc[interruptNum] = userFunc;
00173     }
00174 }
00175 
<a name="l00176"></a><a class="code" href="group__timer.html#ga9">00176</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga9">timerDetach</a>(u08 interruptNum)
00177 {
00178     <span class="comment">// make sure the interrupt number is within bounds</span>
00179     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00180     {
00181         <span class="comment">// set the interrupt function to run nothing</span>
00182         TimerIntFunc[interruptNum] = 0;
00183     }
00184 }
00185 <span class="comment">/*</span>
00186 <span class="comment">u32 timerMsToTics(u16 ms)</span>
00187 <span class="comment">{</span>
00188 <span class="comment">    // calculate the prescaler division rate</span>
00189 <span class="comment">    u16 prescaleDiv = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));</span>
00190 <span class="comment">    // calculate the number of timer tics in x milliseconds</span>
00191 <span class="comment">    return (ms*(F_CPU/(prescaleDiv*256)))/1000;</span>
00192 <span class="comment">}</span>
00193 <span class="comment"></span>
00194 <span class="comment">u16 timerTicsToMs(u32 tics)</span>
00195 <span class="comment">{</span>
00196 <span class="comment">    // calculate the prescaler division rate</span>
00197 <span class="comment">    u16 prescaleDiv = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));</span>
00198 <span class="comment">    // calculate the number of milliseconds in x timer tics</span>
00199 <span class="comment">    return (tics*1000*(prescaleDiv*256))/F_CPU;</span>
00200 <span class="comment">}</span>
00201 <span class="comment">*/</span>
<a name="l00202"></a><a class="code" href="group__timer.html#ga10">00202</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga10">timerPause</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> pause_ms)
00203 {
00204     <span class="comment">// pauses for exactly &lt;pause_ms&gt; number of milliseconds</span>
00205     u08 timerThres;
00206     u32 ticRateHz;
00207     u32 pause;
00208 
00209     <span class="comment">// capture current pause timer value</span>
00210     timerThres = TCNT0;
00211     <span class="comment">// reset pause timer overflow count</span>
00212     TimerPauseReg = 0;
00213     <span class="comment">// calculate delay for [pause_ms] milliseconds</span>
00214     <span class="comment">// prescaler division = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)))</span>
00215     ticRateHz = F_CPU/<a class="code" href="group__timer.html#ga5">timer0GetPrescaler</a>();
00216     <span class="comment">// precision management</span>
00217     <span class="comment">// prevent overflow and precision underflow</span>
00218     <span class="comment">//  -could add more conditions to improve accuracy</span>
00219     <span class="keywordflow">if</span>( ((ticRateHz &lt; 429497) &amp;&amp; (pause_ms &lt;= 10000)) )
00220         pause = (pause_ms*ticRateHz)/1000;
00221     <span class="keywordflow">else</span>
00222         pause = pause_ms*(ticRateHz/1000);
00223 
00224     <span class="comment">// loop until time expires</span>
00225     <span class="keywordflow">while</span>( ((TimerPauseReg&lt;&lt;8) | (TCNT0)) &lt; (pause+timerThres) )
00226     {
00227         <span class="keywordflow">if</span>( TimerPauseReg &lt; (pause&gt;&gt;8));
00228         {
00229             <span class="comment">// save power by idling the processor</span>
00230             set_sleep_mode(SLEEP_MODE_IDLE);
00231             sleep_mode();
00232         }
00233     }
00234 
00235     <span class="comment">/* old inaccurate code, for reference</span>
00236 <span class="comment">    </span>
00237 <span class="comment">    // calculate delay for [pause_ms] milliseconds</span>
00238 <span class="comment">    u16 prescaleDiv = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));</span>
00239 <span class="comment">    u32 pause = (pause_ms*(F_CPU/(prescaleDiv*256)))/1000;</span>
00240 <span class="comment">    </span>
00241 <span class="comment">    TimerPauseReg = 0;</span>
00242 <span class="comment">    while(TimerPauseReg &lt; pause);</span>
00243 <span class="comment"></span>
00244 <span class="comment">    */</span>
00245 }
00246 
<a name="l00247"></a><a class="code" href="group__timer.html#ga11">00247</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga11">timer0ClearOverflowCount</a>(<span class="keywordtype">void</span>)
00248 {
00249     <span class="comment">// clear the timer overflow counter registers</span>
00250     Timer0Reg0 = 0; <span class="comment">// initialize time registers</span>
00251 }
00252 
<a name="l00253"></a><a class="code" href="group__timer.html#ga12">00253</a> <span class="keywordtype">long</span> <a class="code" href="group__timer.html#ga12">timer0GetOverflowCount</a>(<span class="keywordtype">void</span>)
00254 {
00255     <span class="comment">// return the current timer overflow count</span>
00256     <span class="comment">// (this is since the last timer0ClearOverflowCount() command was called)</span>
00257     <span class="keywordflow">return</span> Timer0Reg0;
00258 }
00259 
00260 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00261 <span class="preprocessor"></span><span class="keywordtype">void</span> timer2ClearOverflowCount(<span class="keywordtype">void</span>)
00262 {
00263     <span class="comment">// clear the timer overflow counter registers</span>
00264     Timer2Reg0 = 0; <span class="comment">// initialize time registers</span>
00265 }
00266 
00267 <span class="keywordtype">long</span> timer2GetOverflowCount(<span class="keywordtype">void</span>)
00268 {
00269     <span class="comment">// return the current timer overflow count</span>
00270     <span class="comment">// (this is since the last timer2ClearOverflowCount() command was called)</span>
00271     <span class="keywordflow">return</span> Timer2Reg0;
00272 }
00273 <span class="preprocessor">#endif</span>
00274 <span class="preprocessor"></span>
<a name="l00275"></a><a class="code" href="group__timerpwm.html#ga0">00275</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga0">timer1PWMInit</a>(u08 bitRes)
00276 {
00277     <span class="comment">// configures timer1 for use with PWM output</span>
00278     <span class="comment">// on OC1A and OC1B pins</span>
00279 
00280     <span class="comment">// enable timer1 as 8,9,10bit PWM</span>
00281     <span class="keywordflow">if</span>(bitRes == 9)
00282     {   <span class="comment">// 9bit mode</span>
00283         sbi(TCCR1A,PWM11);
00284         cbi(TCCR1A,PWM10);
00285     }
00286     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( bitRes == 10 )
00287     {   <span class="comment">// 10bit mode</span>
00288         sbi(TCCR1A,PWM11);
00289         sbi(TCCR1A,PWM10);
00290     }
00291     <span class="keywordflow">else</span>
00292     {   <span class="comment">// default 8bit mode</span>
00293         cbi(TCCR1A,PWM11);
00294         sbi(TCCR1A,PWM10);
00295     }
00296 
00297     <span class="comment">// clear output compare value A</span>
00298     OCR1A = 0;
00299     <span class="comment">// clear output compare value B</span>
00300     OCR1B = 0;
00301 }
00302 
00303 <span class="preprocessor">#ifdef WGM10</span>
00304 <span class="preprocessor"></span><span class="comment">// include support for arbitrary top-count PWM</span>
00305 <span class="comment">// on new AVR processors that support it</span>
00306 <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga1">timer1PWMInitICR</a>(u16 topcount)
00307 {
00308     <span class="comment">// set PWM mode with ICR top-count</span>
00309     cbi(TCCR1A,WGM10);
00310     sbi(TCCR1A,WGM11);
00311     sbi(TCCR1B,WGM12);
00312     sbi(TCCR1B,WGM13);
00313     
00314     <span class="comment">// set top count value</span>
00315     ICR1 = topcount;
00316     
00317     <span class="comment">// clear output compare value A</span>
00318     OCR1A = 0;
00319     <span class="comment">// clear output compare value B</span>
00320     OCR1B = 0;
00321 
00322 }
00323 <span class="preprocessor">#endif</span>
00324 <span class="preprocessor"></span>
<a name="l00325"></a><a class="code" href="group__timerpwm.html#ga2">00325</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga2">timer1PWMOff</a>(<span class="keywordtype">void</span>)
00326 {
00327     <span class="comment">// turn off timer1 PWM mode</span>
00328     cbi(TCCR1A,PWM11);
00329     cbi(TCCR1A,PWM10);
00330     <span class="comment">// set PWM1A/B (OutputCompare action) to none</span>
00331     <a class="code" href="group__timerpwm.html#ga5">timer1PWMAOff</a>();
00332     <a class="code" href="group__timerpwm.html#ga6">timer1PWMBOff</a>();
00333 }
00334 
<a name="l00335"></a><a class="code" href="group__timerpwm.html#ga3">00335</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga3">timer1PWMAOn</a>(<span class="keywordtype">void</span>)
00336 {
00337     <span class="comment">// turn on channel A (OC1A) PWM output</span>
00338     <span class="comment">// set OC1A as non-inverted PWM</span>
00339     sbi(TCCR1A,COM1A1);
00340     cbi(TCCR1A,COM1A0);
00341 }
00342 
<a name="l00343"></a><a class="code" href="group__timerpwm.html#ga4">00343</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga4">timer1PWMBOn</a>(<span class="keywordtype">void</span>)
00344 {
00345     <span class="comment">// turn on channel B (OC1B) PWM output</span>
00346     <span class="comment">// set OC1B as non-inverted PWM</span>
00347     sbi(TCCR1A,COM1B1);
00348     cbi(TCCR1A,COM1B0);
00349 }
00350 
<a name="l00351"></a><a class="code" href="group__timerpwm.html#ga5">00351</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga5">timer1PWMAOff</a>(<span class="keywordtype">void</span>)
00352 {
00353     <span class="comment">// turn off channel A (OC1A) PWM output</span>
00354     <span class="comment">// set OC1A (OutputCompare action) to none</span>
00355     cbi(TCCR1A,COM1A1);
00356     cbi(TCCR1A,COM1A0);
00357 }
00358 
<a name="l00359"></a><a class="code" href="group__timerpwm.html#ga6">00359</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga6">timer1PWMBOff</a>(<span class="keywordtype">void</span>)
00360 {
00361     <span class="comment">// turn off channel B (OC1B) PWM output</span>
00362     <span class="comment">// set OC1B (OutputCompare action) to none</span>
00363     cbi(TCCR1A,COM1B1);
00364     cbi(TCCR1A,COM1B0);
00365 }
00366 
<a name="l00367"></a><a class="code" href="group__timerpwm.html#ga7">00367</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga7">timer1PWMASet</a>(u16 pwmDuty)
00368 {
00369     <span class="comment">// set PWM (output compare) duty for channel A</span>
00370     <span class="comment">// this PWM output is generated on OC1A pin</span>
00371     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00372     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00373     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00374     <span class="comment">//outp( (pwmDuty&gt;&gt;8), OCR1AH);      // set the high 8bits of OCR1A</span>
00375     <span class="comment">//outp( (pwmDuty&amp;0x00FF), OCR1AL);  // set the low 8bits of OCR1A</span>
00376     OCR1A = pwmDuty;
00377 }
00378 
<a name="l00379"></a><a class="code" href="group__timerpwm.html#ga8">00379</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga8">timer1PWMBSet</a>(u16 pwmDuty)
00380 {
00381     <span class="comment">// set PWM (output compare) duty for channel B</span>
00382     <span class="comment">// this PWM output is generated on OC1B pin</span>
00383     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00384     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00385     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00386     <span class="comment">//outp( (pwmDuty&gt;&gt;8), OCR1BH);      // set the high 8bits of OCR1B</span>
00387     <span class="comment">//outp( (pwmDuty&amp;0x00FF), OCR1BL);  // set the low 8bits of OCR1B</span>
00388     OCR1B = pwmDuty;
00389 }
00390 <span class="comment"></span>
00391 <span class="comment">//! Interrupt handler for tcnt0 overflow interrupt</span>
<a name="l00392"></a><a class="code" href="timerx8_8c.html#a27">00392</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW0)
00393 {
00394     Timer0Reg0++;           <span class="comment">// increment low-order counter</span>
00395 
00396     <span class="comment">// increment pause counter</span>
00397     TimerPauseReg++;
00398 
00399     <span class="comment">// if a user function is defined, execute it too</span>
00400     <span class="keywordflow">if</span>(TimerIntFunc[TIMER0OVERFLOW_INT])
00401         TimerIntFunc[TIMER0OVERFLOW_INT]();
00402 }
00403 <span class="comment"></span>
00404 <span class="comment">//! Interrupt handler for tcnt1 overflow interrupt</span>
<a name="l00405"></a><a class="code" href="timerx8_8c.html#a28">00405</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW1)
00406 {
00407     <span class="comment">// if a user function is defined, execute it</span>
00408     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OVERFLOW_INT])
00409         TimerIntFunc[TIMER1OVERFLOW_INT]();
00410 }
00411 
00412 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00413 <span class="preprocessor"></span><span class="comment">//! Interrupt handler for tcnt2 overflow interrupt</span>
00414 <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW2)
00415 {
00416     Timer2Reg0++;           <span class="comment">// increment low-order counter</span>
00417 
00418     <span class="comment">// if a user function is defined, execute it</span>
00419     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OVERFLOW_INT])
00420         TimerIntFunc[TIMER2OVERFLOW_INT]();
00421 }
00422 <span class="preprocessor">#endif</span>
00423 <span class="preprocessor"></span>
00424 <span class="preprocessor">#ifdef OCR0</span>
00425 <span class="preprocessor"></span><span class="comment">// include support for Output Compare 0 for new AVR processors that support it</span><span class="comment"></span>
00426 <span class="comment">//! Interrupt handler for OutputCompare0 match (OC0) interrupt</span>
00427 <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE0)
00428 {
00429     <span class="comment">// if a user function is defined, execute it</span>
00430     <span class="keywordflow">if</span>(TimerIntFunc[TIMER0OUTCOMPARE_INT])
00431         TimerIntFunc[TIMER0OUTCOMPARE_INT]();
00432 }
00433 <span class="preprocessor">#endif</span>
00434 <span class="preprocessor"></span><span class="comment"></span>
00435 <span class="comment">//! Interrupt handler for CutputCompare1A match (OC1A) interrupt</span>
<a name="l00436"></a><a class="code" href="timerx8_8c.html#a29">00436</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1A)
00437 {
00438     <span class="comment">// if a user function is defined, execute it</span>
00439     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREA_INT])
00440         TimerIntFunc[TIMER1OUTCOMPAREA_INT]();
00441 }
00442 <span class="comment"></span>
00443 <span class="comment">//! Interrupt handler for OutputCompare1B match (OC1B) interrupt</span>
<a name="l00444"></a><a class="code" href="timerx8_8c.html#a30">00444</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1B)
00445 {
00446     <span class="comment">// if a user function is defined, execute it</span>
00447     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREB_INT])
00448         TimerIntFunc[TIMER1OUTCOMPAREB_INT]();
00449 }
00450 <span class="comment"></span>
00451 <span class="comment">//! Interrupt handler for InputCapture1 (IC1) interrupt</span>
<a name="l00452"></a><a class="code" href="timerx8_8c.html#a31">00452</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_INPUT_CAPTURE1)
00453 {
00454     <span class="comment">// if a user function is defined, execute it</span>
00455     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1INPUTCAPTURE_INT])
00456         TimerIntFunc[TIMER1INPUTCAPTURE_INT]();
00457 }
00458 <span class="comment"></span>
00459 <span class="comment">//! Interrupt handler for OutputCompare2A match (OC2A) interrupt</span>
<a name="l00460"></a><a class="code" href="timerx8_8c.html#a32">00460</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE2A)
00461 {
00462     <span class="comment">// if a user function is defined, execute it</span>
00463     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OUTCOMPARE_INT])
00464         TimerIntFunc[TIMER2OUTCOMPARE_INT]();
00465 }
00466 <span class="comment"></span>
00467 <span class="comment">//! Interrupt handler for OutputCompare2B match (OC2B) interrupt</span>
<a name="l00468"></a><a class="code" href="timerx8_8c.html#a33">00468</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE2B)
00469 {
00470     <span class="comment">// if a user function is defined, execute it</span>
00471     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OUTCOMPARE_INT])
00472         TimerIntFunc[TIMER2OUTCOMPARE_INT]();
00473 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Aug 22 04:29:28 2005 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
