<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: net/ax88796.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000001.html">net</a></div>
<h1>ax88796.c</h1><a href="ax88796_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file ax88796.c \brief ASIX AX88796 Ethernet Interface Driver. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'ax88796.c'</span>
00005 <span class="comment">// Title        : ASIX AX88796 Ethernet Interface Driver</span>
00006 <span class="comment">// Author       : Pascal Stang</span>
00007 <span class="comment">// Created      : 10/22/2002</span>
00008 <span class="comment">// Revised      : 8/21/2005</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : Atmel AVR series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// Description  : This driver provides initialization and transmit/receive</span>
00014 <span class="comment">//      functions for the ASIX AX88796 10/100Mb Ethernet Controller and PHY.</span>
00015 <span class="comment">//</span>
00016 <span class="comment">// Based in part on code by Louis Beaudoin (www.embedded-creations.com).</span>
00017 <span class="comment">// Thanks to Adam Dunkels and Louis Beaudoin for providing the initial</span>
00018 <span class="comment">// structure in which to write this driver.</span>
00019 <span class="comment">//</span>
00020 <span class="comment">//*****************************************************************************</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00023 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00024 <span class="preprocessor">#include "<a class="code" href="rprintf_8h.html">rprintf.h</a>"</span>
00025 
00026 <span class="preprocessor">#include "<a class="code" href="ax88796_8h.html">ax88796.h</a>"</span>
00027 
00028 <span class="comment">// include configuration</span>
00029 <span class="preprocessor">#include "<a class="code" href="ax88796conf_8h.html">ax88796conf.h</a>"</span>
00030 
00031 <span class="comment">// pointers to locations in the ax88796 receive buffer</span>
00032 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> NextPage;              <span class="comment">// page pointer to next Rx packet</span>
00033 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> CurrentRetreiveAddress; <span class="comment">// DMA address for read Rx packet location</span>
00034 
00035 
<a name="l00036"></a><a class="code" href="group__nic.html#ga0">00036</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga0">nicInit</a>(<span class="keywordtype">void</span>)
00037 {
00038     ax88796Init();
00039 }
00040 
<a name="l00041"></a><a class="code" href="group__nic.html#ga1">00041</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga1">nicSend</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* packet)
00042 {
00043     ax88796BeginPacketSend(len);
00044     ax88796SendPacketData(packet, len);
00045     ax88796EndPacketSend();
00046 }
00047 
<a name="l00048"></a><a class="code" href="group__nic.html#ga2">00048</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="group__nic.html#ga2">nicPoll</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxlen, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* packet)
00049 {
00050     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packetLength;
00051     
00052     packetLength = ax88796BeginPacketRetreive();
00053 
00054     <span class="comment">// if there's no packet or an error - exit without ending the operation</span>
00055     <span class="keywordflow">if</span>( !packetLength )
00056         <span class="keywordflow">return</span> 0;
00057 
00058     <span class="comment">// drop anything too big for the buffer</span>
00059     <span class="keywordflow">if</span>( packetLength &gt; maxlen )
00060     {
00061         ax88796EndPacketRetreive();
00062         <span class="keywordflow">return</span> 0;
00063     }
00064     
00065     <span class="comment">// copy the packet data into the uIP packet buffer</span>
00066     ax88796RetreivePacketData( packet, packetLength );
00067     ax88796EndPacketRetreive();
00068         
00069     <span class="keywordflow">return</span> packetLength;
00070 }
00071 
<a name="l00072"></a><a class="code" href="group__nic.html#ga3">00072</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga3">nicGetMacAddress</a>(u08* macaddr)
00073 {
00074     u08 tempCR;
00075     <span class="comment">// switch register pages</span>
00076     tempCR = ax88796Read(CR);
00077     ax88796Write(CR,tempCR|PS0);
00078     <span class="comment">// read MAC address registers</span>
00079     *macaddr++ = ax88796Read(PAR0);
00080     *macaddr++ = ax88796Read(PAR1);
00081     *macaddr++ = ax88796Read(PAR2);
00082     *macaddr++ = ax88796Read(PAR3);
00083     *macaddr++ = ax88796Read(PAR4);
00084     *macaddr++ = ax88796Read(PAR5);
00085     <span class="comment">// switch register pages back</span>
00086     ax88796Write(CR,tempCR);
00087 }
00088 
<a name="l00089"></a><a class="code" href="group__nic.html#ga4">00089</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga4">nicRegDump</a>(<span class="keywordtype">void</span>)
00090 {
00091     ax88796RegDump();
00092 }
00093 
00094 
00095 <span class="keywordtype">void</span> ax88796SetupPorts(<span class="keywordtype">void</span>)
00096 {
00097 <span class="preprocessor">#if NIC_CONNECTION == MEMORY_MAPPED</span>
00098 <span class="preprocessor"></span>    <span class="comment">// enable external SRAM interface - no wait states</span>
00099     sbi(MCUCR, SRE);
00100 <span class="comment">//  sbi(MCUCR, SRW10);</span>
00101 <span class="comment">//  sbi(XMCRA, SRW00);</span>
00102 <span class="comment">//  sbi(XMCRA, SRW01);</span>
00103 <span class="comment">//  sbi(XMCRA, SRW11);</span>
00104 <span class="preprocessor">#else</span>
00105 <span class="preprocessor"></span>    <span class="comment">// set address port to output</span>
00106     AX88796_ADDRESS_DDR = AX88796_ADDRESS_MASK;
00107     
00108     <span class="comment">// set data port to input with pull-ups</span>
00109     AX88796_DATA_DDR = 0x00;
00110     AX88796_DATA_PORT = 0xFF;
00111 
00112     <span class="comment">// initialize the control port read and write pins to de-asserted</span>
00113     sbi( AX88796_CONTROL_PORT, AX88796_CONTROL_READPIN );
00114     sbi( AX88796_CONTROL_PORT, AX88796_CONTROL_WRITEPIN );
00115     <span class="comment">// set the read and write pins to output</span>
00116     sbi( AX88796_CONTROL_DDR, AX88796_CONTROL_READPIN );
00117     sbi( AX88796_CONTROL_DDR, AX88796_CONTROL_WRITEPIN );
00118 <span class="preprocessor">#endif</span>
00119 <span class="preprocessor"></span>    <span class="comment">// set reset pin to output</span>
00120     sbi( AX88796_RESET_DDR, AX88796_RESET_PIN );
00121 }
00122 
00123 
00124 <span class="preprocessor">#if NIC_CONNECTION == MEMORY_MAPPED</span>
00125 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> ax88796Write(u08 address, u08 data)
00126 {
00127     *(<span class="keyword">volatile</span> u08*)(AX88796_MEMORY_MAPPED_OFFSET + address) = data;
00128 }
00129 <span class="preprocessor">#else</span>
00130 <span class="preprocessor"></span><span class="keywordtype">void</span> ax88796Write(u08 address, u08 data)
00131 {
00132     <span class="comment">// assert the address</span>
00133     AX88796_ADDRESS_PORT = address | (AX88796_ADDRESS_PORT&amp;~AX88796_ADDRESS_MASK);
00134 
00135     <span class="comment">// set data bus as output and place data on bus</span>
00136     AX88796_DATA_DDR = 0xFF;
00137     AX88796_DATA_PORT = data;
00138     
00139     <span class="comment">// clock write pin</span>
00140     cbi(AX88796_CONTROL_PORT, AX88796_CONTROL_WRITEPIN);
00141     nop();
00142     nop();
00143     sbi(AX88796_CONTROL_PORT, AX88796_CONTROL_WRITEPIN);
00144     
00145     <span class="comment">// set data bus back to input with pullups enabled</span>
00146     AX88796_DATA_DDR = 0x00;
00147     AX88796_DATA_PORT = 0xFF;
00148 }
00149 <span class="preprocessor">#endif</span>
00150 <span class="preprocessor"></span>
00151 
00152 <span class="preprocessor">#if NIC_CONNECTION == MEMORY_MAPPED</span>
00153 <span class="preprocessor"></span><span class="keyword">inline</span> u08 ax88796Read(u08 address)
00154 {
00155     <span class="keywordflow">return</span> *(<span class="keyword">volatile</span> u08*)(AX88796_MEMORY_MAPPED_OFFSET + address);
00156 }
00157 <span class="preprocessor">#else</span>
00158 <span class="preprocessor"></span>u08 ax88796Read(u08 address)
00159 {
00160     u08 data;
00161    
00162     <span class="comment">// assert the address</span>
00163     AX88796_ADDRESS_PORT = address | (AX88796_ADDRESS_PORT&amp;~AX88796_ADDRESS_MASK);
00164 
00165     <span class="comment">// assert read</span>
00166     cbi(AX88796_CONTROL_PORT, AX88796_CONTROL_READPIN);
00167     nop();
00168     nop();
00169     <span class="comment">// read in the data</span>
00170     data = AX88796_DATA_PIN;
00171 
00172     <span class="comment">// negate read</span>
00173     sbi(AX88796_CONTROL_PORT, AX88796_CONTROL_READPIN);
00174 
00175     <span class="keywordflow">return</span> data;
00176 }
00177 <span class="preprocessor">#endif                       </span>
00178 <span class="preprocessor"></span>
00179 
00180 <span class="keywordtype">void</span> ax88796Init(<span class="keywordtype">void</span>)
00181 {
00182     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tcrFduFlag;
00183     
00184     <span class="comment">// initialize I/O ports</span>
00185     ax88796SetupPorts();
00186 
00187     <span class="comment">// do a hard reset</span>
00188     sbi(AX88796_RESET_PORT, AX88796_RESET_PIN);
00189     delay_ms(100);
00190     cbi(AX88796_RESET_PORT, AX88796_RESET_PIN);
00191 
00192     <span class="comment">// do soft reset</span>
00193     ax88796Write(ISR, ax88796Read(ISR));
00194     delay_ms(50);
00195 
00196     <span class="comment">// wait for PHY to come out of reset</span>
00197     ax88796Read(RSTPORT);
00198     <span class="keywordflow">while</span>(ax88796Read(TR) &amp; RST_B);
00199   
00200     ax88796WriteMii(0x10,0x00,0x0800);
00201     delay_ms(255);
00202     ax88796WriteMii(0x10,0x00,0x1200);
00203 
00204     ax88796Write(CR,(RD2|STOP));        <span class="comment">// stop the NIC, abort DMA, page 0</span>
00205     delay_ms(5);                        <span class="comment">// make sure nothing is coming in or going out</span>
00206     ax88796Write(DCR,DCR_INIT);    
00207     ax88796Write(RBCR0,0x00);
00208     ax88796Write(RBCR1,0x00);
00209     ax88796Write(IMR,0x00);
00210     ax88796Write(ISR,0xFF);
00211     ax88796Write(RCR,0x20);
00212     ax88796Write(BNRY,RXSTART_INIT);
00213     ax88796Write(PSTART,RXSTART_INIT);
00214     ax88796Write(PSTOP,RXSTOP_INIT);
00215     
00216     <span class="comment">// switch to page 1</span>
00217     ax88796Write(CR,(PS0|RD2|STOP));
00218     <span class="comment">// write mac address</span>
00219     ax88796Write(PAR0+0, AX88796_MAC0);
00220     ax88796Write(PAR0+1, AX88796_MAC1);
00221     ax88796Write(PAR0+2, AX88796_MAC2);
00222     ax88796Write(PAR0+3, AX88796_MAC3);
00223     ax88796Write(PAR0+4, AX88796_MAC4);
00224     ax88796Write(PAR0+5, AX88796_MAC5);
00225     <span class="comment">// set start point</span>
00226     ax88796Write(CURR,RXSTART_INIT+1);
00227 
00228     ax88796Write(CR,(RD2|START));
00229     ax88796Write(RCR,RCR_INIT);
00230 
00231     <span class="keywordflow">if</span>(ax88796Read(GPI) &amp; I_SPD)        <span class="comment">// check PHY speed setting</span>
00232         tcrFduFlag = FDU;               <span class="comment">// if 100base, do full duplex</span>
00233     <span class="keywordflow">else</span>
00234         tcrFduFlag = 0;                 <span class="comment">// if 10base, do half duplex</span>
00235         
00236     ax88796Write(TCR,(tcrFduFlag|TCR_INIT));
00237 
00238     ax88796Write(GPOC,MPSEL);           <span class="comment">// select media interface</span>
00239   
00240     ax88796Write(TPSR,TXSTART_INIT);
00241 
00242     ax88796Write(CR,(RD2|STOP));
00243     ax88796Write(DCR,DCR_INIT);
00244     ax88796Write(CR,(RD2|START));
00245     ax88796Write(ISR,0xFF);
00246     ax88796Write(IMR,IMR_INIT);
00247     ax88796Write(TCR,(tcrFduFlag|TCR_INIT));
00248 
00249     <span class="comment">//test</span>
00250 <span class="comment">/*</span>
00251 <span class="comment">    while(1)</span>
00252 <span class="comment">    {</span>
00253 <span class="comment">        vt100SetCursorPos(18,0);</span>
00254 <span class="comment">        ax88796RegDump();</span>
00255 <span class="comment">    }</span>
00256 <span class="comment">*/</span>
00257 }
00258 
00259 
00260 <span class="keywordtype">void</span> ax88796BeginPacketSend(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packetLength)
00261 {
00262     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sendPacketLength;
00263     sendPacketLength = (packetLength&gt;=ETHERNET_MIN_PACKET_LENGTH)?
00264                         (packetLength):(ETHERNET_MIN_PACKET_LENGTH);
00265     
00266     <span class="comment">//start the NIC</span>
00267     ax88796Write(CR,(RD2|START));
00268     
00269     <span class="comment">// still transmitting a packet - wait for it to finish</span>
00270     <span class="keywordflow">while</span>( ax88796Read(CR) &amp; TXP );
00271 
00272     <span class="comment">//load beginning page for transmit buffer</span>
00273     ax88796Write(TPSR,TXSTART_INIT);
00274     
00275     <span class="comment">//set start address for remote DMA operation</span>
00276     ax88796Write(RSAR0,0x00);
00277     ax88796Write(RSAR1,0x40);
00278     
00279     <span class="comment">//clear the packet stored interrupt</span>
00280     ax88796Write(ISR, PTX);
00281 
00282     <span class="comment">//load data byte count for remote DMA</span>
00283     ax88796Write(RBCR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(packetLength));
00284     ax88796Write(RBCR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(packetLength&gt;&gt;8));
00285 
00286     ax88796Write(TBCR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(sendPacketLength));
00287     ax88796Write(TBCR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)((sendPacketLength)&gt;&gt;8));
00288     
00289     <span class="comment">//do remote write operation</span>
00290     ax88796Write(CR,0x12);
00291 }
00292 
00293 
00294 <span class="keywordtype">void</span> ax88796SendPacketData(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * localBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length)
00295 {
00296     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00297     
00298     <span class="keywordflow">for</span>(i=0;i&lt;length;i++)
00299         ax88796Write(RDMAPORT, localBuffer[i]);
00300 }
00301 
00302 
00303 <span class="keywordtype">void</span> ax88796EndPacketSend(<span class="keywordtype">void</span>)
00304 {
00305     <span class="comment">//send the contents of the transmit buffer onto the network</span>
00306     ax88796Write(CR,(RD2|TXP));
00307     
00308     <span class="comment">// clear the remote DMA interrupt</span>
00309     ax88796Write(ISR, RDC);
00310 }
00311 
00312 
00313 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ax88796BeginPacketRetreive(<span class="keywordtype">void</span>)
00314 {
00315     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> writePagePtr;
00316     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> readPagePtr;
00317     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bnryPagePtr;
00318     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i;
00319     
00320     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pageheader[4];
00321     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rxlen;
00322     
00323     <span class="comment">// check for and handle an overflow</span>
00324     ax88796ProcessInterrupt();
00325     
00326     <span class="comment">// read CURR from page 1</span>
00327     ax88796Write(CR,(PS0|RD2|START));
00328     writePagePtr = ax88796Read(CURR);
00329     <span class="comment">// read the boundary register from page 0</span>
00330     ax88796Write(CR,(RD2|START));
00331     bnryPagePtr = ax88796Read(BNRY);
00332 
00333     <span class="comment">// first packet is at page bnryPtr+1</span>
00334     readPagePtr = bnryPagePtr+1;
00335     <span class="keywordflow">if</span>(readPagePtr &gt;= RXSTOP_INIT) readPagePtr = RXSTART_INIT;
00336     
00337     <span class="comment">// return if there is no packet in the buffer</span>
00338     <span class="keywordflow">if</span>( readPagePtr == writePagePtr )
00339     {
00340         <span class="keywordflow">return</span> 0;
00341     }
00342     
00343     <span class="comment">// clear the packet received interrupt flag</span>
00344     ax88796Write(ISR, PRX);
00345     
00346     <span class="comment">// if the boundary pointer is invalid,</span>
00347     <span class="comment">// reset the contents of the buffer and exit</span>
00348     <span class="keywordflow">if</span>( (bnryPagePtr &lt; RXSTART_INIT) || (bnryPagePtr &gt;= RXSTOP_INIT) )
00349     {
00350         ax88796Write(BNRY, RXSTART_INIT);
00351         ax88796Write(CR, (PS0|RD2|START));
00352         ax88796Write(CURR, RXSTART_INIT+1);
00353         ax88796Write(CR, (RD2|START));
00354         
00355 <span class="comment">//      rprintf("B");</span>
00356         <span class="keywordflow">return</span> 0;
00357     }
00358 
00359     <span class="comment">// initiate DMA to transfer the RTL8019 packet header</span>
00360     ax88796Write(RBCR0, 4);
00361     ax88796Write(RBCR1, 0);
00362     ax88796Write(RSAR0, 0);
00363     ax88796Write(RSAR1, readPagePtr);
00364     ax88796Write(CR, (RD0|START));
00365     <span class="keywordflow">for</span>(i=0;i&lt;4;i++)
00366         pageheader[i] = ax88796Read(RDMAPORT);
00367 
00368     <span class="comment">// end the DMA operation</span>
00369     ax88796Write(CR, (RD2|START));
00370     <span class="keywordflow">for</span>(i = 0; i &lt;= 20; i++)
00371         <span class="keywordflow">if</span>(ax88796Read(ISR) &amp; RDC)
00372             <span class="keywordflow">break</span>;
00373     ax88796Write(ISR, RDC);
00374     
00375     rxlen = (pageheader[PKTHEADER_PKTLENH]&lt;&lt;8) + pageheader[PKTHEADER_PKTLENL];
00376     NextPage = pageheader[PKTHEADER_NEXTPAGE];
00377     
00378     CurrentRetreiveAddress = (readPagePtr&lt;&lt;8) + 4;
00379     
00380     <span class="comment">// if the NextPage pointer is invalid, the packet is not ready yet - exit</span>
00381     <span class="keywordflow">if</span>( (NextPage &gt;= RXSTOP_INIT) || (NextPage &lt; RXSTART_INIT) )
00382     {
00383 <span class="comment">//      rprintf("N");</span>
00384 <span class="comment">//      rprintfu08(nextPage);</span>
00385         <span class="keywordflow">return</span> 0;
00386     }
00387 
00388     <span class="keywordflow">return</span> rxlen-4;
00389 }
00390 
00391 
00392 <span class="keywordtype">void</span> ax88796RetreivePacketData(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * localBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length)
00393 {
00394     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00395     
00396     <span class="comment">// initiate DMA to transfer the data</span>
00397     ax88796Write(RBCR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)length);
00398     ax88796Write(RBCR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(length&gt;&gt;8));
00399     ax88796Write(RSAR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)CurrentRetreiveAddress);
00400     ax88796Write(RSAR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(CurrentRetreiveAddress&gt;&gt;8));
00401     ax88796Write(CR, (RD0|START));
00402     <span class="keywordflow">for</span>(i=0;i&lt;length;i++)
00403         localBuffer[i] = ax88796Read(RDMAPORT);
00404 
00405     <span class="comment">// end the DMA operation</span>
00406     ax88796Write(CR, (RD2|START));
00407     <span class="keywordflow">for</span>(i = 0; i &lt;= 20; i++)
00408         <span class="keywordflow">if</span>(ax88796Read(ISR) &amp; RDC)
00409             <span class="keywordflow">break</span>;
00410     ax88796Write(ISR, RDC);
00411     
00412     CurrentRetreiveAddress += length;
00413     <span class="keywordflow">if</span>( CurrentRetreiveAddress &gt;= 0x6000 )
00414         CurrentRetreiveAddress -= (0x6000-0x4600) ;
00415 }
00416 
00417 
00418 <span class="keywordtype">void</span> ax88796EndPacketRetreive(<span class="keywordtype">void</span>)
00419 {
00420     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i;
00421     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bnryPagePtr;
00422 
00423     <span class="comment">// end the DMA operation</span>
00424     ax88796Write(CR, (RD2|START));
00425     <span class="keywordflow">for</span>(i = 0; i &lt;= 20; i++)
00426         <span class="keywordflow">if</span>(ax88796Read(ISR) &amp; RDC)
00427             <span class="keywordflow">break</span>;
00428     ax88796Write(ISR, RDC);
00429 
00430     <span class="comment">// set the boundary register to point</span>
00431     <span class="comment">// to the start of the next packet-1</span>
00432     bnryPagePtr = NextPage-1;
00433     <span class="keywordflow">if</span>(bnryPagePtr &lt; RXSTART_INIT) bnryPagePtr = RXSTOP_INIT-1;
00434 
00435     ax88796Write(BNRY, bnryPagePtr);
00436 }
00437 
00438 
00439 <span class="keywordtype">void</span> ax88796ProcessInterrupt(<span class="keywordtype">void</span>)
00440 {
00441     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> intr = ax88796Read(ISR);
00442     
00443     <span class="comment">// check for receive overflow</span>
00444     <span class="keywordflow">if</span>( intr &amp; OVW )
00445         ax88796ReceiveOverflowRecover();
00446 }
00447 
00448 
00449 <span class="keywordtype">void</span> ax88796ReceiveOverflowRecover(<span class="keywordtype">void</span>)
00450 {
00451     <span class="comment">// receive buffer overflow handling procedure</span>
00452     <span class="comment">// as specified in the AX88796 datasheet</span>
00453 
00454     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> cmdReg;
00455     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> resend=0;
00456 
00457     <span class="comment">// check if we were transmitting something</span>
00458     cmdReg = ax88796Read(CR);
00459     <span class="comment">// stop the interface</span>
00460     ax88796Write(CR, (RD2|STOP));
00461     <span class="comment">// wait for timeout</span>
00462     delay_ms(2);
00463     <span class="comment">// clear remote byte count registers</span>
00464     ax88796Write(RBCR0, 0x00);
00465     ax88796Write(RBCR1, 0x00);
00466     
00467     <span class="comment">// if we were transmitting something</span>
00468     <span class="keywordflow">if</span>(cmdReg &amp; TXP)
00469     {
00470         <span class="comment">// check if the transmit completed</span>
00471         cmdReg = ax88796Read(ISR);
00472         <span class="keywordflow">if</span>((cmdReg &amp; PTX) || (cmdReg &amp; TXE))
00473             resend = 0;     <span class="comment">// transmit completed</span>
00474         <span class="keywordflow">else</span>
00475             resend = 1;     <span class="comment">// transmit was interrupted, must resend</span>
00476     }
00477     <span class="comment">// switch to loopback mode</span>
00478     ax88796Write(TCR, LB0);
00479     <span class="comment">// start the interface</span>
00480     ax88796Write(CR, (RD2|START));
00481     <span class="comment">// set boundary</span>
00482     ax88796Write(BNRY, RXSTART_INIT);
00483     <span class="comment">// go to page 1</span>
00484     ax88796Write(CR, (PS0|RD2|START));
00485     <span class="comment">// set current page register</span>
00486     ax88796Write(CPR, RXSTART_INIT+1);
00487     <span class="comment">// go to page 0</span>
00488     ax88796Write(CR, (RD2|START));
00489     <span class="comment">// clear the overflow int</span>
00490     ax88796Write(ISR, OVW);
00491     <span class="comment">// switch to normal (non-loopback mode)</span>
00492     ax88796Write(TCR, TCR_INIT);
00493 
00494     <span class="comment">// if previous transmit was interrupted, then resend</span>
00495     <span class="keywordflow">if</span>(resend)
00496         ax88796Write(CR, (RD2|TXP|START));
00497 
00498     <span class="comment">// recovery completed</span>
00499 }
00500 
00501 
00502 <span class="preprocessor">#define set_mdc     ax88796Write(MEMR,ax88796Read(MEMR)|0x01);</span>
00503 <span class="preprocessor"></span><span class="preprocessor">#define clr_mdc     ax88796Write(MEMR,ax88796Read(MEMR)&amp;0xFE);</span>
00504 <span class="preprocessor"></span>
00505 <span class="preprocessor">#define mii_clk     set_mdc; clr_mdc;                 </span>
00506 <span class="preprocessor"></span>                    
00507 <span class="preprocessor">#define set_mdir    ax88796Write(MEMR,ax88796Read(MEMR)|0x02);</span>
00508 <span class="preprocessor"></span><span class="preprocessor">#define clr_mdir    ax88796Write(MEMR,ax88796Read(MEMR)&amp;0xFD);</span>
00509 <span class="preprocessor"></span>                    
00510 <span class="preprocessor">#define set_mdo     ax88796Write(MEMR,ax88796Read(MEMR)|0x08)</span>
00511 <span class="preprocessor"></span><span class="preprocessor">#define clr_mdo     ax88796Write(MEMR,ax88796Read(MEMR)&amp;0xF7)</span>
00512 <span class="preprocessor"></span>
00513 <span class="preprocessor">#define mii_write   clr_mdo; mii_clk;   \</span>
00514 <span class="preprocessor">                    set_mdo; mii_clk;   \</span>
00515 <span class="preprocessor">                    clr_mdo; mii_clk;   \</span>
00516 <span class="preprocessor">                    set_mdo; mii_clk;</span>
00517 <span class="preprocessor"></span>
00518 <span class="preprocessor">#define mii_read    clr_mdo; mii_clk;   \</span>
00519 <span class="preprocessor">                    set_mdo; mii_clk;   \</span>
00520 <span class="preprocessor">                    set_mdo; mii_clk;   \</span>
00521 <span class="preprocessor">                    clr_mdo; mii_clk;</span>
00522 <span class="preprocessor"></span>
00523 <span class="preprocessor">#define mii_r_ta    mii_clk;            \</span>
00524 <span class="preprocessor"></span>
00525 <span class="preprocessor"></span><span class="preprocessor">#define mii_w_ta    set_mdo; mii_clk;   \</span>
00526 <span class="preprocessor">                    clr_mdo; mii_clk;</span>
00527 <span class="preprocessor"></span>            
00528 <span class="keywordtype">void</span> ax88796WriteMii(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> phyad,<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> regad,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mii_data)
00529 {
00530     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mask8;
00531     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  i,mask16;
00532 
00533     mii_write;
00534  
00535     mask8 = 0x10;
00536     <span class="keywordflow">for</span>(i=0;i&lt;5;++i)
00537     {
00538         <span class="keywordflow">if</span>(mask8 &amp; phyad)
00539             set_mdo;
00540         <span class="keywordflow">else</span>
00541             clr_mdo;
00542         mii_clk;
00543         mask8 &gt;&gt;= 1;     
00544     }   
00545     mask8 = 0x10;
00546     <span class="keywordflow">for</span>(i=0;i&lt;5;++i)
00547     {
00548         <span class="keywordflow">if</span>(mask8 &amp; regad)
00549             set_mdo;
00550         <span class="keywordflow">else</span>
00551             clr_mdo;
00552         mii_clk;
00553         mask8 &gt;&gt;= 1;     
00554     }                       
00555     mii_w_ta;
00556  
00557     mask16 = 0x8000;
00558     <span class="keywordflow">for</span>(i=0;i&lt;16;++i)
00559     {
00560         <span class="keywordflow">if</span>(mask16 &amp; mii_data)
00561             set_mdo;
00562         <span class="keywordflow">else</span>
00563             clr_mdo;
00564         mii_clk;     
00565         mask16 &gt;&gt;= 1;    
00566     }               
00567 }
00568  
00569 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ax88796ReadMii(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> phyad,<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> regad)
00570 {
00571     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mask8,i;
00572     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  mask16,result16;
00573  
00574     mii_read;
00575 
00576     mask8 = 0x10;
00577     <span class="keywordflow">for</span>(i=0;i&lt;5;++i)
00578     {
00579         <span class="keywordflow">if</span>(mask8 &amp; phyad)
00580             set_mdo;
00581         <span class="keywordflow">else</span>
00582             clr_mdo;
00583         mii_clk;     
00584         mask8 &gt;&gt;= 1;
00585     }
00586     mask8 = 0x10;
00587     <span class="keywordflow">for</span>(i=0;i&lt;5;++i)
00588     {
00589         <span class="keywordflow">if</span>(mask8 &amp; regad)
00590             set_mdo;
00591         <span class="keywordflow">else</span>
00592             clr_mdo;
00593         mii_clk;
00594         mask8 &gt;&gt;= 1;
00595     }
00596             
00597     mii_r_ta;
00598  
00599     mask16 = 0x8000;
00600     result16 = 0x0000;
00601     <span class="keywordflow">for</span>(i=0;i&lt;16;++i)
00602     {
00603         mii_clk;
00604         <span class="keywordflow">if</span>(ax88796Read(MEMR) &amp; 0x04)
00605         {
00606             result16 |= mask16;
00607         }
00608         <span class="keywordflow">else</span>
00609         {
00610             <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00611             <span class="keywordflow">break</span>;
00612         }
00613         mask16 &gt;&gt;= 1;
00614     }
00615     <span class="keywordflow">return</span> result16;
00616 }
00617 
00618 
00619 <span class="keywordtype">void</span> ax88796RegDump(<span class="keywordtype">void</span>)
00620 {
00621     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> result;
00622     result = ax88796Read(TR);
00623     
00624     rprintf(<span class="stringliteral">"Media State: "</span>);
00625     <span class="keywordflow">if</span>(!(result &amp; AUTOD))
00626         rprintf(<span class="stringliteral">"Autonegotiation\r\n"</span>);
00627     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(result &amp; RST_B)
00628         rprintf(<span class="stringliteral">"PHY in Reset   \r\n"</span>);
00629     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!(result &amp; RST_10B))
00630         rprintf(<span class="stringliteral">"10BASE-T       \r\n"</span>);
00631     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!(result &amp; RST_TXB))
00632         rprintf(<span class="stringliteral">"100BASE-T      \r\n"</span>);
00633                 
00634     <span class="comment">//rprintf("TR regsiter      : %x\r\n",result);</span>
00635     <span class="comment">//result = read_mii(0x10,0);</span>
00636     <span class="comment">//rprintf("MII regsiter 0x10: %x\r\n",result);</span>
00637 
00638     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"Page0: CR  BNRY PSR PST ISR TSR RSR MMR TR  GPI\r\n"</span>);
00639     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"       "</span>);
00640     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(CR));
00641     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00642     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(BNRY));
00643     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"   "</span>);
00644     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(PSTART));
00645     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00646     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(PSTOP));
00647     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00648     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(ISR));
00649     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00650     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(TSR));
00651     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00652     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(RSR));
00653     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00654     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(MEMR));
00655     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00656     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(TR));
00657     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00658     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(GPI));
00659     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00660 
00661     ax88796Write(CR,ax88796Read(CR)|PS0);
00662 
00663     rprintf(<span class="stringliteral">"Page1: CR  PAR    CPR\r\n"</span>);
00664     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"       "</span>);
00665     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(CR));
00666     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00667     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR0));
00668     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR1));
00669     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR2));
00670     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR3));
00671     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR4));
00672     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR5));
00673     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" "</span>);
00674     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(CPR));
00675     
00676     ax88796Write(CR,ax88796Read(CR)&amp;~PS0);
00677 
00678     delay_ms(25);
00679 }
00680 
00681 <span class="comment">/*</span>
00682 <span class="comment">unsigned char ax88796ReceiveEmpty(void)</span>
00683 <span class="comment">{</span>
00684 <span class="comment">    unsigned char temp;</span>
00685 <span class="comment"></span>
00686 <span class="comment">    // read CPR from page 1</span>
00687 <span class="comment">    ax88796Write(CR,0x62);</span>
00688 <span class="comment">    temp = ax88796Read(CPR);</span>
00689 <span class="comment">    </span>
00690 <span class="comment">    // return to page 0</span>
00691 <span class="comment">    ax88796Write(CR,0x22);</span>
00692 <span class="comment">    </span>
00693 <span class="comment">    return ( ax88796Read(BNRY) == temp );</span>
00694 <span class="comment">    </span>
00695 <span class="comment">}*/</span>
00696 
00697 
00698 
00699 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Aug 22 04:29:27 2005 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
