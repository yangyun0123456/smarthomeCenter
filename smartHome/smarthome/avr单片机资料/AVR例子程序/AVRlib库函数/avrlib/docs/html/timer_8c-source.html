<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: timer.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>timer.c</h1><a href="timer_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file timer.c \brief System Timer function library. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'timer.c'</span>
00005 <span class="comment">// Title        : System Timer function library</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2000-2002</span>
00007 <span class="comment">// Created      : 11/22/2000</span>
00008 <span class="comment">// Revised      : 07/09/2003</span>
00009 <span class="comment">// Version      : 1.1</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#ifndef WIN32</span>
00019 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;avr/io.h&gt;</span>
00020 <span class="preprocessor">    #include &lt;avr/signal.h&gt;</span>
00021 <span class="preprocessor">    #include &lt;avr/interrupt.h&gt;</span>
00022 <span class="preprocessor">    #include &lt;avr/pgmspace.h&gt;</span>
00023 <span class="preprocessor">    #include &lt;avr/sleep.h&gt;</span>
00024 <span class="preprocessor">#endif</span>
00025 <span class="preprocessor"></span>
00026 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00027 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00028 
00029 <span class="preprocessor">#include "<a class="code" href="rprintf_8h.html">rprintf.h</a>"</span>
00030 
00031 <span class="comment">// Program ROM constants</span>
00032 <span class="comment">// the prescale division values stored in order of timer control register index</span>
00033 <span class="comment">// STOP, CLK, CLK/8, CLK/64, CLK/256, CLK/1024</span>
00034 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> __attribute__ ((progmem)) TimerPrescaleFactor[] = {0,1,8,64,256,1024};
00035 <span class="comment">// the prescale division values stored in order of timer control register index</span>
00036 <span class="comment">// STOP, CLK, CLK/8, CLK/32, CLK/64, CLK/128, CLK/256, CLK/1024</span>
00037 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> __attribute__ ((progmem)) TimerRTCPrescaleFactor[] = {0,1,8,32,64,128,256,1024};
00038 
00039 <span class="comment">// Global variables</span>
00040 <span class="comment">// time registers</span>
00041 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> TimerPauseReg;
00042 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer0Reg0;
00043 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer2Reg0;
00044 
00045 <span class="keyword">typedef</span> void (*voidFuncPtr)(void);
00046 <span class="keyword">volatile</span> <span class="keyword">static</span> voidFuncPtr TimerIntFunc[TIMER_NUM_INTERRUPTS];
00047 
00048 <span class="comment">// delay for a minimum of &lt;us&gt; microseconds </span>
00049 <span class="comment">// the time resolution is dependent on the time the loop takes </span>
00050 <span class="comment">// e.g. with 4Mhz and 5 cycles per loop, the resolution is 1.25 us </span>
00051 <span class="keywordtype">void</span> delay_us(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> time_us) 
00052 {
00053     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> delay_loops;
00054     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i;
00055 
00056     delay_loops = (time_us+3)/5*CYCLES_PER_US; <span class="comment">// +3 for rounding up (dirty) </span>
00057 
00058     <span class="comment">// one loop takes 5 cpu cycles </span>
00059     <span class="keywordflow">for</span> (i=0; i &lt; delay_loops; i++) {};
00060 }
00061 <span class="comment">/*</span>
00062 <span class="comment">void delay_ms(unsigned char time_ms)</span>
00063 <span class="comment">{</span>
00064 <span class="comment">    unsigned short delay_count = F_CPU / 4000;</span>
00065 <span class="comment"></span>
00066 <span class="comment">    unsigned short cnt;</span>
00067 <span class="comment">    asm volatile ("\n"</span>
00068 <span class="comment">                  "L_dl1%=:\n\t"</span>
00069 <span class="comment">                  "mov %A0, %A2\n\t"</span>
00070 <span class="comment">                  "mov %B0, %B2\n"</span>
00071 <span class="comment">                  "L_dl2%=:\n\t"</span>
00072 <span class="comment">                  "sbiw %A0, 1\n\t"</span>
00073 <span class="comment">                  "brne L_dl2%=\n\t"</span>
00074 <span class="comment">                  "dec %1\n\t" "brne L_dl1%=\n\t":"=&amp;w" (cnt)</span>
00075 <span class="comment">                  :"r"(time_ms), "r"((unsigned short) (delay_count))</span>
00076 <span class="comment">    );</span>
00077 <span class="comment">}</span>
00078 <span class="comment">*/</span>
<a name="l00079"></a><a class="code" href="group__timerx8.html#ga1">00079</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga1">timerInit</a>(<span class="keywordtype">void</span>)
00080 {
00081     u08 intNum;
00082     <span class="comment">// detach all user functions from interrupts</span>
00083     <span class="keywordflow">for</span>(intNum=0; intNum&lt;TIMER_NUM_INTERRUPTS; intNum++)
00084         <a class="code" href="group__timer.html#ga9">timerDetach</a>(intNum);
00085 
00086     <span class="comment">// initialize all timers</span>
00087     <a class="code" href="group__timer.html#ga2">timer0Init</a>();
00088     <a class="code" href="group__timer.html#ga3">timer1Init</a>();
00089 <span class="preprocessor">    #ifdef TCNT2    // support timer2 only if it exists</span>
00090 <span class="preprocessor"></span>    timer2Init();
00091 <span class="preprocessor">    #endif</span>
00092 <span class="preprocessor"></span>    <span class="comment">// enable interrupts</span>
00093     sei();
00094 }
00095 
<a name="l00096"></a><a class="code" href="group__timerx8.html#ga2">00096</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga2">timer0Init</a>()
00097 {
00098     <span class="comment">// initialize timer 0</span>
00099     <a class="code" href="group__timer.html#ga4">timer0SetPrescaler</a>( <a class="code" href="group__timer.html#ga33">TIMER0PRESCALE</a> );   <span class="comment">// set prescaler</span>
00100     outb(TCNT0, 0);                         <span class="comment">// reset TCNT0</span>
00101     sbi(TIMSK, TOIE0);                      <span class="comment">// enable TCNT0 overflow interrupt</span>
00102 
00103     <a class="code" href="group__timer.html#ga11">timer0ClearOverflowCount</a>();             <span class="comment">// initialize time registers</span>
00104 }
00105 
<a name="l00106"></a><a class="code" href="group__timerx8.html#ga3">00106</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga3">timer1Init</a>(<span class="keywordtype">void</span>)
00107 {
00108     <span class="comment">// initialize timer 1</span>
00109     <a class="code" href="group__timer.html#ga6">timer1SetPrescaler</a>( <a class="code" href="group__timer.html#ga34">TIMER1PRESCALE</a> );   <span class="comment">// set prescaler</span>
00110     outb(TCNT1H, 0);                        <span class="comment">// reset TCNT1</span>
00111     outb(TCNT1L, 0);
00112     sbi(TIMSK, TOIE1);                      <span class="comment">// enable TCNT1 overflow</span>
00113 }
00114 
00115 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00116 <span class="preprocessor"></span><span class="keywordtype">void</span> timer2Init(<span class="keywordtype">void</span>)
00117 {
00118     <span class="comment">// initialize timer 2</span>
00119     <a class="code" href="group__timer128.html#ga8">timer2SetPrescaler</a>( <a class="code" href="group__timer.html#ga35">TIMER2PRESCALE</a> );   <span class="comment">// set prescaler</span>
00120     outb(TCNT2, 0);                         <span class="comment">// reset TCNT2</span>
00121     sbi(TIMSK, TOIE2);                      <span class="comment">// enable TCNT2 overflow</span>
00122 
00123     timer2ClearOverflowCount();             <span class="comment">// initialize time registers</span>
00124 }
00125 <span class="preprocessor">#endif</span>
00126 <span class="preprocessor"></span>
<a name="l00127"></a><a class="code" href="group__timerx8.html#ga4">00127</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga4">timer0SetPrescaler</a>(u08 prescale)
00128 {
00129     <span class="comment">// set prescaler on timer 0</span>
00130     outb(TCCR0, (inb(TCCR0) &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00131 }
00132 
<a name="l00133"></a><a class="code" href="group__timerx8.html#ga6">00133</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga6">timer1SetPrescaler</a>(u08 prescale)
00134 {
00135     <span class="comment">// set prescaler on timer 1</span>
00136     outb(TCCR1B, (inb(TCCR1B) &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00137 }
00138 
00139 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00140 <span class="preprocessor"></span><span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga8">timer2SetPrescaler</a>(u08 prescale)
00141 {
00142     <span class="comment">// set prescaler on timer 2</span>
00143     outb(TCCR2, (inb(TCCR2) &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00144 }
00145 <span class="preprocessor">#endif</span>
00146 <span class="preprocessor"></span>
<a name="l00147"></a><a class="code" href="group__timerx8.html#ga5">00147</a> u16 <a class="code" href="group__timer.html#ga5">timer0GetPrescaler</a>(<span class="keywordtype">void</span>)
00148 {
00149     <span class="comment">// get the current prescaler setting</span>
00150     <span class="keywordflow">return</span> (pgm_read_word(TimerPrescaleFactor+(inb(TCCR0) &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00151 }
00152 
<a name="l00153"></a><a class="code" href="group__timerx8.html#ga7">00153</a> u16 <a class="code" href="group__timer.html#ga7">timer1GetPrescaler</a>(<span class="keywordtype">void</span>)
00154 {
00155     <span class="comment">// get the current prescaler setting</span>
00156     <span class="keywordflow">return</span> (pgm_read_word(TimerPrescaleFactor+(inb(TCCR1B) &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00157 }
00158 
00159 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00160 <span class="preprocessor"></span>u16 <a class="code" href="group__timer128.html#ga12">timer2GetPrescaler</a>(<span class="keywordtype">void</span>)
00161 {
00162     <span class="comment">//TODO: can we assume for all 3-timer AVR processors,</span>
00163     <span class="comment">// that timer2 is the RTC timer?</span>
00164 
00165     <span class="comment">// get the current prescaler setting</span>
00166     <span class="keywordflow">return</span> (pgm_read_word(TimerRTCPrescaleFactor+(inb(TCCR2) &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00167 }
00168 <span class="preprocessor">#endif</span>
00169 <span class="preprocessor"></span>
<a name="l00170"></a><a class="code" href="group__timerx8.html#ga8">00170</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga8">timerAttach</a>(u08 interruptNum, <span class="keywordtype">void</span> (*userFunc)(<span class="keywordtype">void</span>) )
00171 {
00172     <span class="comment">// make sure the interrupt number is within bounds</span>
00173     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00174     {
00175         <span class="comment">// set the interrupt function to run</span>
00176         <span class="comment">// the supplied user's function</span>
00177         TimerIntFunc[interruptNum] = userFunc;
00178     }
00179 }
00180 
<a name="l00181"></a><a class="code" href="group__timerx8.html#ga9">00181</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga9">timerDetach</a>(u08 interruptNum)
00182 {
00183     <span class="comment">// make sure the interrupt number is within bounds</span>
00184     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00185     {
00186         <span class="comment">// set the interrupt function to run nothing</span>
00187         TimerIntFunc[interruptNum] = 0;
00188     }
00189 }
00190 <span class="comment">/*</span>
00191 <span class="comment">u32 timerMsToTics(u16 ms)</span>
00192 <span class="comment">{</span>
00193 <span class="comment">    // calculate the prescaler division rate</span>
00194 <span class="comment">    u16 prescaleDiv = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));</span>
00195 <span class="comment">    // calculate the number of timer tics in x milliseconds</span>
00196 <span class="comment">    return (ms*(F_CPU/(prescaleDiv*256)))/1000;</span>
00197 <span class="comment">}</span>
00198 <span class="comment"></span>
00199 <span class="comment">u16 timerTicsToMs(u32 tics)</span>
00200 <span class="comment">{</span>
00201 <span class="comment">    // calculate the prescaler division rate</span>
00202 <span class="comment">    u16 prescaleDiv = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));</span>
00203 <span class="comment">    // calculate the number of milliseconds in x timer tics</span>
00204 <span class="comment">    return (tics*1000*(prescaleDiv*256))/F_CPU;</span>
00205 <span class="comment">}</span>
00206 <span class="comment">*/</span>
<a name="l00207"></a><a class="code" href="group__timerx8.html#ga10">00207</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga10">timerPause</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> pause_ms)
00208 {
00209     <span class="comment">// pauses for exactly &lt;pause_ms&gt; number of milliseconds</span>
00210     u08 timerThres;
00211     u32 ticRateHz;
00212     u32 pause;
00213 
00214     <span class="comment">// capture current pause timer value</span>
00215     timerThres = inb(TCNT0);
00216     <span class="comment">// reset pause timer overflow count</span>
00217     TimerPauseReg = 0;
00218     <span class="comment">// calculate delay for [pause_ms] milliseconds</span>
00219     <span class="comment">// prescaler division = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)))</span>
00220     ticRateHz = F_CPU/<a class="code" href="group__timer.html#ga5">timer0GetPrescaler</a>();
00221     <span class="comment">// precision management</span>
00222     <span class="comment">// prevent overflow and precision underflow</span>
00223     <span class="comment">//  -could add more conditions to improve accuracy</span>
00224     <span class="keywordflow">if</span>( ((ticRateHz &lt; 429497) &amp;&amp; (pause_ms &lt;= 10000)) )
00225         pause = (pause_ms*ticRateHz)/1000;
00226     <span class="keywordflow">else</span>
00227         pause = pause_ms*(ticRateHz/1000);
00228 
00229     <span class="comment">// loop until time expires</span>
00230     <span class="keywordflow">while</span>( ((TimerPauseReg&lt;&lt;8) | inb(TCNT0)) &lt; (pause+timerThres) )
00231     {
00232         <span class="keywordflow">if</span>( TimerPauseReg &lt; (pause&gt;&gt;8));
00233         {
00234             <span class="comment">// save power by idling the processor</span>
00235             set_sleep_mode(SLEEP_MODE_IDLE);
00236             sleep_mode();
00237         }
00238     }
00239 
00240     <span class="comment">/* old inaccurate code, for reference</span>
00241 <span class="comment">    </span>
00242 <span class="comment">    // calculate delay for [pause_ms] milliseconds</span>
00243 <span class="comment">    u16 prescaleDiv = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));</span>
00244 <span class="comment">    u32 pause = (pause_ms*(F_CPU/(prescaleDiv*256)))/1000;</span>
00245 <span class="comment">    </span>
00246 <span class="comment">    TimerPauseReg = 0;</span>
00247 <span class="comment">    while(TimerPauseReg &lt; pause);</span>
00248 <span class="comment"></span>
00249 <span class="comment">    */</span>
00250 }
00251 
<a name="l00252"></a><a class="code" href="group__timerx8.html#ga11">00252</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga11">timer0ClearOverflowCount</a>(<span class="keywordtype">void</span>)
00253 {
00254     <span class="comment">// clear the timer overflow counter registers</span>
00255     Timer0Reg0 = 0; <span class="comment">// initialize time registers</span>
00256 }
00257 
<a name="l00258"></a><a class="code" href="group__timerx8.html#ga12">00258</a> <span class="keywordtype">long</span> <a class="code" href="group__timer.html#ga12">timer0GetOverflowCount</a>(<span class="keywordtype">void</span>)
00259 {
00260     <span class="comment">// return the current timer overflow count</span>
00261     <span class="comment">// (this is since the last timer0ClearOverflowCount() command was called)</span>
00262     <span class="keywordflow">return</span> Timer0Reg0;
00263 }
00264 
00265 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00266 <span class="preprocessor"></span><span class="keywordtype">void</span> timer2ClearOverflowCount(<span class="keywordtype">void</span>)
00267 {
00268     <span class="comment">// clear the timer overflow counter registers</span>
00269     Timer2Reg0 = 0; <span class="comment">// initialize time registers</span>
00270 }
00271 
00272 <span class="keywordtype">long</span> timer2GetOverflowCount(<span class="keywordtype">void</span>)
00273 {
00274     <span class="comment">// return the current timer overflow count</span>
00275     <span class="comment">// (this is since the last timer2ClearOverflowCount() command was called)</span>
00276     <span class="keywordflow">return</span> Timer2Reg0;
00277 }
00278 <span class="preprocessor">#endif</span>
00279 <span class="preprocessor"></span>
<a name="l00280"></a><a class="code" href="group__timerpwm.html#ga0">00280</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga0">timer1PWMInit</a>(u08 bitRes)
00281 {
00282     <span class="comment">// configures timer1 for use with PWM output</span>
00283     <span class="comment">// on OC1A and OC1B pins</span>
00284 
00285     <span class="comment">// enable timer1 as 8,9,10bit PWM</span>
00286     <span class="keywordflow">if</span>(bitRes == 9)
00287     {   <span class="comment">// 9bit mode</span>
00288         sbi(TCCR1A,PWM11);
00289         cbi(TCCR1A,PWM10);
00290     }
00291     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( bitRes == 10 )
00292     {   <span class="comment">// 10bit mode</span>
00293         sbi(TCCR1A,PWM11);
00294         sbi(TCCR1A,PWM10);
00295     }
00296     <span class="keywordflow">else</span>
00297     {   <span class="comment">// default 8bit mode</span>
00298         cbi(TCCR1A,PWM11);
00299         sbi(TCCR1A,PWM10);
00300     }
00301 
00302     <span class="comment">// clear output compare value A</span>
00303     outb(OCR1AH, 0);
00304     outb(OCR1AL, 0);
00305     <span class="comment">// clear output compare value B</span>
00306     outb(OCR1BH, 0);
00307     outb(OCR1BL, 0);
00308 }
00309 
00310 <span class="preprocessor">#ifdef WGM10</span>
00311 <span class="preprocessor"></span><span class="comment">// include support for arbitrary top-count PWM</span>
00312 <span class="comment">// on new AVR processors that support it</span>
00313 <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga1">timer1PWMInitICR</a>(u16 topcount)
00314 {
00315     <span class="comment">// set PWM mode with ICR top-count</span>
00316     cbi(TCCR1A,WGM10);
00317     sbi(TCCR1A,WGM11);
00318     sbi(TCCR1B,WGM12);
00319     sbi(TCCR1B,WGM13);
00320     
00321     <span class="comment">// set top count value</span>
00322     ICR1 = topcount;
00323     
00324     <span class="comment">// clear output compare value A</span>
00325     OCR1A = 0;
00326     <span class="comment">// clear output compare value B</span>
00327     OCR1B = 0;
00328 
00329 }
00330 <span class="preprocessor">#endif</span>
00331 <span class="preprocessor"></span>
<a name="l00332"></a><a class="code" href="group__timer128.html#ga23">00332</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga2">timer1PWMOff</a>(<span class="keywordtype">void</span>)
00333 {
00334     <span class="comment">// turn off timer1 PWM mode</span>
00335     cbi(TCCR1A,PWM11);
00336     cbi(TCCR1A,PWM10);
00337     <span class="comment">// set PWM1A/B (OutputCompare action) to none</span>
00338     <a class="code" href="group__timerpwm.html#ga5">timer1PWMAOff</a>();
00339     <a class="code" href="group__timerpwm.html#ga6">timer1PWMBOff</a>();
00340 }
00341 
<a name="l00342"></a><a class="code" href="group__timer128.html#ga24">00342</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga3">timer1PWMAOn</a>(<span class="keywordtype">void</span>)
00343 {
00344     <span class="comment">// turn on channel A (OC1A) PWM output</span>
00345     <span class="comment">// set OC1A as non-inverted PWM</span>
00346     sbi(TCCR1A,COM1A1);
00347     cbi(TCCR1A,COM1A0);
00348 }
00349 
<a name="l00350"></a><a class="code" href="group__timer128.html#ga25">00350</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga4">timer1PWMBOn</a>(<span class="keywordtype">void</span>)
00351 {
00352     <span class="comment">// turn on channel B (OC1B) PWM output</span>
00353     <span class="comment">// set OC1B as non-inverted PWM</span>
00354     sbi(TCCR1A,COM1B1);
00355     cbi(TCCR1A,COM1B0);
00356 }
00357 
<a name="l00358"></a><a class="code" href="group__timer128.html#ga27">00358</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga5">timer1PWMAOff</a>(<span class="keywordtype">void</span>)
00359 {
00360     <span class="comment">// turn off channel A (OC1A) PWM output</span>
00361     <span class="comment">// set OC1A (OutputCompare action) to none</span>
00362     cbi(TCCR1A,COM1A1);
00363     cbi(TCCR1A,COM1A0);
00364 }
00365 
<a name="l00366"></a><a class="code" href="group__timer128.html#ga28">00366</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga6">timer1PWMBOff</a>(<span class="keywordtype">void</span>)
00367 {
00368     <span class="comment">// turn off channel B (OC1B) PWM output</span>
00369     <span class="comment">// set OC1B (OutputCompare action) to none</span>
00370     cbi(TCCR1A,COM1B1);
00371     cbi(TCCR1A,COM1B0);
00372 }
00373 
<a name="l00374"></a><a class="code" href="group__timer128.html#ga30">00374</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga7">timer1PWMASet</a>(u16 pwmDuty)
00375 {
00376     <span class="comment">// set PWM (output compare) duty for channel A</span>
00377     <span class="comment">// this PWM output is generated on OC1A pin</span>
00378     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00379     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00380     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00381     <span class="comment">//outp( (pwmDuty&gt;&gt;8), OCR1AH);      // set the high 8bits of OCR1A</span>
00382     <span class="comment">//outp( (pwmDuty&amp;0x00FF), OCR1AL);  // set the low 8bits of OCR1A</span>
00383     OCR1A = pwmDuty;
00384 }
00385 
<a name="l00386"></a><a class="code" href="group__timer128.html#ga31">00386</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga8">timer1PWMBSet</a>(u16 pwmDuty)
00387 {
00388     <span class="comment">// set PWM (output compare) duty for channel B</span>
00389     <span class="comment">// this PWM output is generated on OC1B pin</span>
00390     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00391     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00392     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00393     <span class="comment">//outp( (pwmDuty&gt;&gt;8), OCR1BH);      // set the high 8bits of OCR1B</span>
00394     <span class="comment">//outp( (pwmDuty&amp;0x00FF), OCR1BL);  // set the low 8bits of OCR1B</span>
00395     OCR1B = pwmDuty;
00396 }
00397 <span class="comment"></span>
00398 <span class="comment">//! Interrupt handler for tcnt0 overflow interrupt</span>
<a name="l00399"></a><a class="code" href="timer_8c.html#a27">00399</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW0)
00400 {
00401     Timer0Reg0++;           <span class="comment">// increment low-order counter</span>
00402 
00403     <span class="comment">// increment pause counter</span>
00404     TimerPauseReg++;
00405 
00406     <span class="comment">// if a user function is defined, execute it too</span>
00407     <span class="keywordflow">if</span>(TimerIntFunc[TIMER0OVERFLOW_INT])
00408         TimerIntFunc[TIMER0OVERFLOW_INT]();
00409 }
00410 <span class="comment"></span>
00411 <span class="comment">//! Interrupt handler for tcnt1 overflow interrupt</span>
<a name="l00412"></a><a class="code" href="timer_8c.html#a28">00412</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW1)
00413 {
00414     <span class="comment">// if a user function is defined, execute it</span>
00415     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OVERFLOW_INT])
00416         TimerIntFunc[TIMER1OVERFLOW_INT]();
00417 }
00418 
00419 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00420 <span class="preprocessor"></span><span class="comment">//! Interrupt handler for tcnt2 overflow interrupt</span>
00421 <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW2)
00422 {
00423     Timer2Reg0++;           <span class="comment">// increment low-order counter</span>
00424 
00425     <span class="comment">// if a user function is defined, execute it</span>
00426     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OVERFLOW_INT])
00427         TimerIntFunc[TIMER2OVERFLOW_INT]();
00428 }
00429 <span class="preprocessor">#endif</span>
00430 <span class="preprocessor"></span>
00431 <span class="preprocessor">#ifdef OCR0</span>
00432 <span class="preprocessor"></span><span class="comment">// include support for Output Compare 0 for new AVR processors that support it</span><span class="comment"></span>
00433 <span class="comment">//! Interrupt handler for OutputCompare0 match (OC0) interrupt</span>
00434 <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE0)
00435 {
00436     <span class="comment">// if a user function is defined, execute it</span>
00437     <span class="keywordflow">if</span>(TimerIntFunc[TIMER0OUTCOMPARE_INT])
00438         TimerIntFunc[TIMER0OUTCOMPARE_INT]();
00439 }
00440 <span class="preprocessor">#endif</span>
00441 <span class="preprocessor"></span><span class="comment"></span>
00442 <span class="comment">//! Interrupt handler for CutputCompare1A match (OC1A) interrupt</span>
<a name="l00443"></a><a class="code" href="timer_8c.html#a29">00443</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1A)
00444 {
00445     <span class="comment">// if a user function is defined, execute it</span>
00446     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREA_INT])
00447         TimerIntFunc[TIMER1OUTCOMPAREA_INT]();
00448 }
00449 <span class="comment"></span>
00450 <span class="comment">//! Interrupt handler for OutputCompare1B match (OC1B) interrupt</span>
<a name="l00451"></a><a class="code" href="timer_8c.html#a30">00451</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1B)
00452 {
00453     <span class="comment">// if a user function is defined, execute it</span>
00454     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREB_INT])
00455         TimerIntFunc[TIMER1OUTCOMPAREB_INT]();
00456 }
00457 <span class="comment"></span>
00458 <span class="comment">//! Interrupt handler for InputCapture1 (IC1) interrupt</span>
<a name="l00459"></a><a class="code" href="timer_8c.html#a31">00459</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_INPUT_CAPTURE1)
00460 {
00461     <span class="comment">// if a user function is defined, execute it</span>
00462     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1INPUTCAPTURE_INT])
00463         TimerIntFunc[TIMER1INPUTCAPTURE_INT]();
00464 }
00465 <span class="comment"></span>
00466 <span class="comment">//! Interrupt handler for OutputCompare2 match (OC2) interrupt</span>
<a name="l00467"></a><a class="code" href="timer_8c.html#a32">00467</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE2)
00468 {
00469     <span class="comment">// if a user function is defined, execute it</span>
00470     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OUTCOMPARE_INT])
00471         TimerIntFunc[TIMER2OUTCOMPARE_INT]();
00472 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Aug 22 04:29:28 2005 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
