<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: net/rtl8019.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000001.html">net</a></div>
<h1>rtl8019.c</h1><a href="rtl8019_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file rtl8019.c \brief Realtek RTL8019AS Ethernet Interface Driver. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'rtl8019.c'</span>
00005 <span class="comment">// Title        : Realtek RTL8019AS Ethernet Interface Driver</span>
00006 <span class="comment">// Author       : Pascal Stang</span>
00007 <span class="comment">// Created      : 7/6/2004</span>
00008 <span class="comment">// Revised      : 8/22/2005</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : Atmel AVR series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">//*****************************************************************************</span>
00014 
00015 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00016 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00017 <span class="preprocessor">#include "<a class="code" href="rprintf_8h.html">rprintf.h</a>"</span>
00018 
00019 <span class="preprocessor">#include "<a class="code" href="rtl8019_8h.html">rtl8019.h</a>"</span>
00020 
00021 <span class="comment">// include configuration</span>
00022 <span class="preprocessor">#include "<a class="code" href="rtl8019conf_8h.html">rtl8019conf.h</a>"</span>
00023 
00024 <span class="comment">// pointers to locations in the RTL8019 receive buffer</span>
00025 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> NextPage;              <span class="comment">// page pointer to next Rx packet</span>
00026 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> CurrentRetreiveAddress; <span class="comment">// DMA address for read Rx packet location</span>
00027 
00028 
<a name="l00029"></a><a class="code" href="group__nic.html#ga0">00029</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga0">nicInit</a>(<span class="keywordtype">void</span>)
00030 {
00031     rtl8019Init();
00032 }
00033 
<a name="l00034"></a><a class="code" href="group__nic.html#ga1">00034</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga1">nicSend</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* packet)
00035 {
00036     rtl8019BeginPacketSend(len);
00037     rtl8019SendPacketData(packet, len);
00038     rtl8019EndPacketSend();
00039 }
00040 
<a name="l00041"></a><a class="code" href="group__nic.html#ga2">00041</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="group__nic.html#ga2">nicPoll</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxlen, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* packet)
00042 {
00043     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packetLength;
00044     
00045     packetLength = rtl8019BeginPacketRetreive();
00046 
00047     <span class="comment">// if there's no packet or an error - exit without ending the operation</span>
00048     <span class="keywordflow">if</span>( !packetLength )
00049         <span class="keywordflow">return</span> 0;
00050 
00051     <span class="comment">// drop anything too big for the buffer</span>
00052     <span class="keywordflow">if</span>( packetLength &gt; maxlen )
00053     {
00054         rtl8019EndPacketRetreive();
00055         <span class="keywordflow">return</span> 0;
00056     }
00057     
00058     <span class="comment">// copy the packet data into the packet buffer</span>
00059     rtl8019RetreivePacketData( packet, packetLength );
00060     rtl8019EndPacketRetreive();
00061         
00062     <span class="keywordflow">return</span> packetLength;
00063 }
00064 
<a name="l00065"></a><a class="code" href="group__nic.html#ga3">00065</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga3">nicGetMacAddress</a>(u08* macaddr)
00066 {
00067     u08 tempCR;
00068     <span class="comment">// switch register pages</span>
00069     tempCR = rtl8019Read(CR);
00070     rtl8019Write(CR,tempCR|PS0);
00071     <span class="comment">// read MAC address registers</span>
00072     *macaddr++ = rtl8019Read(PAR0);
00073     *macaddr++ = rtl8019Read(PAR1);
00074     *macaddr++ = rtl8019Read(PAR2);
00075     *macaddr++ = rtl8019Read(PAR3);
00076     *macaddr++ = rtl8019Read(PAR4);
00077     *macaddr++ = rtl8019Read(PAR5);
00078     <span class="comment">// switch register pages back</span>
00079     rtl8019Write(CR,tempCR);
00080 }
00081 
<a name="l00082"></a><a class="code" href="group__nic.html#ga4">00082</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga4">nicRegDump</a>(<span class="keywordtype">void</span>)
00083 {
00084     rtl8019RegDump();
00085 }
00086 
00087 
00088 <span class="keywordtype">void</span> rtl8019SetupPorts(<span class="keywordtype">void</span>)
00089 {
00090 <span class="preprocessor">#if NIC_CONNECTION == MEMORY_MAPPED</span>
00091 <span class="preprocessor"></span>    <span class="comment">// enable external SRAM interface - no wait states</span>
00092     sbi(MCUCR, SRE);
00093 <span class="comment">//  sbi(MCUCR, SRW10);</span>
00094 <span class="comment">//  sbi(XMCRA, SRW00);</span>
00095 <span class="comment">//  sbi(XMCRA, SRW01);</span>
00096 <span class="comment">//  sbi(XMCRA, SRW11);</span>
00097 <span class="preprocessor">#else</span>
00098 <span class="preprocessor"></span>    <span class="comment">// make the address port output</span>
00099     RTL8019_ADDRESS_DDR = RTL8019_ADDRESS_MASK;
00100     <span class="comment">// make the data port input with pull-ups</span>
00101     RTL8019_DATA_PORT = 0xFF;
00102 
00103     <span class="comment">// initialize the control port read and write pins to de-asserted</span>
00104     RTL8019_CONTROL_DDR |= (1&lt;&lt;RTL8019_CONTROL_READPIN);
00105     RTL8019_CONTROL_DDR |= (1&lt;&lt;RTL8019_CONTROL_WRITEPIN);
00106     <span class="comment">// set the read and write pins to output</span>
00107     RTL8019_CONTROL_PORT |= (1&lt;&lt;RTL8019_CONTROL_READPIN);
00108     RTL8019_CONTROL_PORT |= (1&lt;&lt;RTL8019_CONTROL_WRITEPIN);
00109 <span class="preprocessor">#endif</span>
00110 <span class="preprocessor"></span>    <span class="comment">// set reset pin to output</span>
00111     sbi(RTL8019_RESET_DDR, RTL8019_RESET_PIN);
00112 }
00113 
00114 
00115 <span class="preprocessor">#if NIC_CONNECTION == MEMORY_MAPPED</span>
00116 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> rtl8019Write(u08 address, u08 data)
00117 {
00118     *(<span class="keyword">volatile</span> u08*)(RTL8019_MEMORY_MAPPED_OFFSET + address) = data;
00119 }
00120 <span class="preprocessor">#else</span>
00121 <span class="preprocessor"></span><span class="keywordtype">void</span> rtl8019Write(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> address, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> data)
00122 {
00123     <span class="comment">// assert the address</span>
00124     RTL8019_ADDRESS_PORT = address | (RTL8019_ADDRESS_PORT&amp;~RTL8019_ADDRESS_MASK);
00125     <span class="comment">// set data bus as output and place data on bus</span>
00126     RTL8019_DATA_DDR = 0xFF;
00127     RTL8019_DATA_PORT = data;
00128     <span class="comment">// clock write pin</span>
00129     cbi(RTL8019_CONTROL_PORT, RTL8019_CONTROL_WRITEPIN);
00130     nop();
00131     nop();
00132     sbi(RTL8019_CONTROL_PORT, RTL8019_CONTROL_WRITEPIN);
00133     <span class="comment">// set data port back to input with pullups enabled</span>
00134     RTL8019_DATA_DDR = 0x00;
00135     RTL8019_DATA_PORT = 0xFF;
00136 }
00137 <span class="preprocessor">#endif</span>
00138 <span class="preprocessor"></span>
00139 
00140 <span class="preprocessor">#if NIC_CONNECTION == MEMORY_MAPPED</span>
00141 <span class="preprocessor"></span><span class="keyword">inline</span> u08 ax88796Read(u08 address)
00142 {
00143     <span class="keywordflow">return</span> *(<span class="keyword">volatile</span> u08*)(RTL8019_MEMORY_MAPPED_OFFSET + address);
00144 }
00145 <span class="preprocessor">#else</span>
00146 <span class="preprocessor"></span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> rtl8019Read(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> address)
00147 {
00148     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> data;
00149    
00150     <span class="comment">// assert the address</span>
00151     RTL8019_ADDRESS_PORT = address | (RTL8019_ADDRESS_PORT&amp;~RTL8019_ADDRESS_MASK);
00152     <span class="comment">// assert read</span>
00153     cbi(RTL8019_CONTROL_PORT, RTL8019_CONTROL_READPIN);
00154     nop();
00155     nop();
00156     <span class="comment">// read in the data</span>
00157     data = RTL8019_DATA_PIN;
00158     <span class="comment">// negate read</span>
00159     sbi(RTL8019_CONTROL_PORT, RTL8019_CONTROL_READPIN);
00160     <span class="comment">// return data</span>
00161     <span class="keywordflow">return</span> data;
00162 }
00163 <span class="preprocessor">#endif                       </span>
00164 <span class="preprocessor"></span>
00165 
00166 <span class="keywordtype">void</span> rtl8019Init(<span class="keywordtype">void</span>)
00167 {
00168     <span class="comment">// setup I/O ports</span>
00169     rtl8019SetupPorts();
00170     
00171     <span class="comment">// do a hard reset</span>
00172     sbi(RTL8019_RESET_PORT, RTL8019_RESET_PIN);
00173     delay_ms(10);
00174     cbi(RTL8019_RESET_PORT, RTL8019_RESET_PIN);
00175 
00176     <span class="comment">// clear interrupt state</span>
00177     rtl8019Write( ISR, rtl8019Read(ISR) );
00178     delay_ms(50);
00179 
00180     <span class="comment">// switch to page 3 to load config registers</span>
00181     rtl8019Write(CR, (PS0|PS1|RD2|STOP));
00182 
00183     <span class="comment">// disable EEPROM write protect of config registers</span>
00184     rtl8019Write(RTL_EECR, (EEM1|EEM0));
00185 
00186     <span class="comment">// set network type to 10 Base-T link test</span>
00187     rtl8019Write(CONFIG2, 0x20);
00188 
00189     <span class="comment">// disable powerdown and sleep</span>
00190     rtl8019Write(CONFIG3, 0);
00191     delay_ms(255);
00192 
00193     <span class="comment">// reenable EEPROM write protect</span>
00194     rtl8019Write(RTL_EECR, 0);
00195 
00196     <span class="comment">// go back to page 0, stop NIC, abort DMA</span>
00197     rtl8019Write(CR, (RD2|STOP));
00198     delay_ms(2);                    <span class="comment">// wait for traffic to complete</span>
00199     rtl8019Write(DCR, DCR_INIT);
00200     rtl8019Write(RBCR0,0x00);
00201     rtl8019Write(RBCR1,0x00);
00202     rtl8019Write(RCR, AB);
00203     rtl8019Write(TPSR, TXSTART_INIT);
00204     rtl8019Write(TCR, LB0);
00205     rtl8019Write(PSTART, RXSTART_INIT);
00206     rtl8019Write(BNRY, RXSTART_INIT);
00207     rtl8019Write(PSTOP, RXSTOP_INIT);
00208     rtl8019Write(CR, (PS0|RD2|STOP));   <span class="comment">// switch to page 1</span>
00209     delay_ms(2);
00210     rtl8019Write(CPR, RXSTART_INIT);
00211     
00212     <span class="comment">// set MAC address</span>
00213     rtl8019Write(PAR0, RTL8019_MAC0);
00214     rtl8019Write(PAR1, RTL8019_MAC1);
00215     rtl8019Write(PAR2, RTL8019_MAC2);
00216     rtl8019Write(PAR3, RTL8019_MAC3);
00217     rtl8019Write(PAR4, RTL8019_MAC4);
00218     rtl8019Write(PAR5, RTL8019_MAC5);
00219     
00220     <span class="comment">// initialize sequence per NE2000 spec</span>
00221     rtl8019Write(CR, (RD2|STOP));
00222     rtl8019Write(DCR, DCR_INIT);
00223     rtl8019Write(CR, (RD2|START));
00224     rtl8019Write(ISR,0xFF);         <span class="comment">// clear all interrupts</span>
00225     rtl8019Write(IMR, IMR_INIT);
00226     rtl8019Write(TCR, TCR_INIT);
00227     
00228     rtl8019Write(CR, (RD2|START));  <span class="comment">// start the NIC</span>
00229 }
00230 
00231 
00232 <span class="keywordtype">void</span> rtl8019BeginPacketSend(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packetLength)
00233 {
00234     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sendPacketLength;
00235     sendPacketLength = (packetLength&gt;=ETHERNET_MIN_PACKET_LENGTH)?
00236                         (packetLength):ETHERNET_MIN_PACKET_LENGTH;
00237     
00238     <span class="comment">//start the NIC</span>
00239     rtl8019Write(CR, (RD2|START));
00240     
00241     <span class="comment">// still transmitting a packet - wait for it to finish</span>
00242     <span class="keywordflow">while</span>( rtl8019Read(CR) &amp; TXP );
00243 
00244     <span class="comment">// load beginning page for transmit buffer</span>
00245     rtl8019Write(TPSR,TXSTART_INIT);
00246     
00247     <span class="comment">// set start address for remote DMA operation</span>
00248     rtl8019Write(RSAR0,0x00);
00249     rtl8019Write(RSAR1,0x40);
00250     
00251     <span class="comment">// clear the packet stored interrupt</span>
00252     rtl8019Write(ISR,PTX);
00253 
00254     <span class="comment">// load data byte count for remote DMA</span>
00255     rtl8019Write(RBCR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(packetLength));
00256     rtl8019Write(RBCR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(packetLength&gt;&gt;8));
00257 
00258     rtl8019Write(TBCR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(sendPacketLength));
00259     rtl8019Write(TBCR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)((sendPacketLength)&gt;&gt;8));
00260     
00261     <span class="comment">// do remote write operation</span>
00262     rtl8019Write(CR,(RD1|START));
00263 }
00264 
00265 
00266 <span class="keywordtype">void</span> rtl8019SendPacketData(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *localBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length)
00267 {
00268     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00269     
00270     <span class="comment">// write data to DMA port</span>
00271     <span class="keywordflow">for</span>(i=0;i&lt;length;i++)
00272         rtl8019Write(RDMAPORT, localBuffer[i]);
00273 }
00274 
00275 
00276 <span class="keywordtype">void</span> rtl8019EndPacketSend(<span class="keywordtype">void</span>)
00277 {
00278     <span class="comment">//send the contents of the transmit buffer onto the network</span>
00279     rtl8019Write(CR,(RD2|TXP));
00280     <span class="comment">// clear the remote DMA interrupt</span>
00281     rtl8019Write(ISR, RDC);
00282 }
00283 
00284 
00285 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rtl8019BeginPacketRetreive(<span class="keywordtype">void</span>)
00286 {
00287     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i;
00288     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bnry;
00289     
00290     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pageheader[4];
00291     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rxlen;
00292     
00293     <span class="comment">// check for and handle an overflow</span>
00294     rtl8019ProcessInterrupt();
00295     
00296     <span class="comment">// read CPR from page 1</span>
00297     rtl8019Write(CR,(PS0|RD2|START));
00298     i = rtl8019Read(CPR);
00299     
00300     <span class="comment">// return to page 0</span>
00301     rtl8019Write(CR,(RD2|START));
00302     
00303     <span class="comment">// read the boundary register - pointing to the beginning of the packet</span>
00304     bnry = rtl8019Read(BNRY) ;
00305     
00306     <span class="comment">// return if there is no packet in the buffer</span>
00307     <span class="keywordflow">if</span>( bnry == i )
00308         <span class="keywordflow">return</span> 0;
00309 
00310     <span class="comment">// clear the packet received interrupt flag</span>
00311     rtl8019Write(ISR, PRX);
00312     
00313     <span class="comment">// if boundary pointer is invalid</span>
00314     <span class="keywordflow">if</span>( (bnry &gt;= RXSTOP_INIT) || (bnry &lt; RXSTART_INIT) )
00315     {
00316         <span class="comment">// reset the contents of the buffer and exit</span>
00317         rtl8019Write(BNRY, RXSTART_INIT);
00318         rtl8019Write(CR, (PS0|RD2|START));
00319         rtl8019Write(CPR, RXSTART_INIT);
00320         rtl8019Write(CR, (RD2|START));
00321         <span class="keywordflow">return</span> 0;
00322     }
00323 
00324     <span class="comment">// initiate DMA to transfer the RTL8019 packet header</span>
00325     rtl8019Write(RBCR0, 4);
00326     rtl8019Write(RBCR1, 0);
00327     rtl8019Write(RSAR0, 0);
00328     rtl8019Write(RSAR1, bnry);
00329     rtl8019Write(CR, (RD0|START));
00330     <span class="comment">// transfer packet header</span>
00331     <span class="keywordflow">for</span>(i=0;i&lt;4;i++)
00332         pageheader[i] = rtl8019Read(RDMAPORT);
00333     <span class="comment">// end the DMA operation</span>
00334     rtl8019Write(CR, (RD2|START));
00335     <span class="comment">// wait for remote DMA complete</span>
00336     <span class="keywordflow">for</span>(i = 0; i &lt; 20; i++)
00337         <span class="keywordflow">if</span>(rtl8019Read(ISR) &amp; RDC)
00338             <span class="keywordflow">break</span>;
00339     rtl8019Write(ISR, RDC);
00340 
00341     rxlen = (pageheader[PKTHEADER_PKTLENH]&lt;&lt;8) + pageheader[PKTHEADER_PKTLENL];
00342     NextPage = pageheader[PKTHEADER_NEXTPAGE];
00343     
00344     CurrentRetreiveAddress = (bnry&lt;&lt;8) + 4;
00345     
00346     <span class="comment">// if the NextPage pointer is invalid, the packet is not ready yet - exit</span>
00347     <span class="keywordflow">if</span>( (NextPage &gt;= RXSTOP_INIT) || (NextPage &lt; RXSTART_INIT) )
00348         <span class="keywordflow">return</span> 0;
00349     
00350     <span class="keywordflow">return</span> rxlen-4;
00351 }
00352 
00353 
00354 <span class="keywordtype">void</span> rtl8019RetreivePacketData(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * localBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length)
00355 {
00356     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00357     
00358     <span class="comment">// initiate DMA to transfer the data</span>
00359     rtl8019Write(RBCR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)length);
00360     rtl8019Write(RBCR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(length&gt;&gt;8));
00361     rtl8019Write(RSAR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)CurrentRetreiveAddress);
00362     rtl8019Write(RSAR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(CurrentRetreiveAddress&gt;&gt;8));
00363     rtl8019Write(CR, (RD0|START));
00364     <span class="comment">// transfer packet data</span>
00365     <span class="keywordflow">for</span>(i=0;i&lt;length;i++)
00366         localBuffer[i] = rtl8019Read(RDMAPORT);
00367     <span class="comment">// end the DMA operation</span>
00368     rtl8019Write(CR, (RD2|START));
00369     <span class="comment">// wait for remote DMA complete</span>
00370     <span class="keywordflow">for</span>(i=0; i&lt;20; i++)
00371         <span class="keywordflow">if</span>(rtl8019Read(ISR) &amp; RDC)
00372             <span class="keywordflow">break</span>;
00373     rtl8019Write(ISR, RDC);
00374     <span class="comment">// keep track of current address</span>
00375     CurrentRetreiveAddress += length;
00376     <span class="keywordflow">if</span>( CurrentRetreiveAddress &gt;= 0x6000 )
00377         CurrentRetreiveAddress = CurrentRetreiveAddress - (0x6000-0x4600) ;
00378 }
00379 
00380 
00381 <span class="keywordtype">void</span> rtl8019EndPacketRetreive(<span class="keywordtype">void</span>)
00382 {
00383     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i;
00384 
00385     <span class="comment">// end the DMA operation</span>
00386     rtl8019Write(CR, (RD2|START));
00387     <span class="comment">// wait for remote DMA complete</span>
00388     <span class="keywordflow">for</span>(i=0; i&lt;20; i++)
00389         <span class="keywordflow">if</span>(rtl8019Read(ISR) &amp; RDC)
00390             <span class="keywordflow">break</span>;
00391     rtl8019Write(ISR, RDC);
00392 
00393     <span class="comment">// set the boundary register to point to the start of the next packet</span>
00394     rtl8019Write(BNRY, NextPage);
00395 }
00396 
00397 
00398 <span class="keywordtype">void</span> rtl8019ProcessInterrupt(<span class="keywordtype">void</span>)
00399 {
00400     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byte = rtl8019Read(ISR);
00401     
00402     <span class="keywordflow">if</span>( byte &amp; OVW )
00403         rtl8019ReceiveOverflowRecover();
00404 }
00405 
00406 <span class="keywordtype">void</span> rtl8019ReceiveOverflowRecover(<span class="keywordtype">void</span>)
00407 {
00408     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> data_L, resend;   
00409 
00410     data_L = rtl8019Read(CR);
00411     rtl8019Write(CR, 0x21);
00412     delay_ms(2);
00413     rtl8019Write(RBCR0, 0x00);
00414     rtl8019Write(RBCR1, 0x00);
00415     <span class="keywordflow">if</span>(!(data_L &amp; 0x04))
00416         resend = 0;
00417     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(data_L &amp; 0x04)
00418     {
00419         data_L = rtl8019Read(ISR);
00420         <span class="keywordflow">if</span>((data_L &amp; 0x02) || (data_L &amp; 0x08))
00421             resend = 0;
00422         <span class="keywordflow">else</span>
00423             resend = 1;
00424     }
00425     
00426     rtl8019Write(TCR, 0x02);
00427     rtl8019Write(CR, 0x22);
00428     rtl8019Write(BNRY, RXSTART_INIT);
00429     rtl8019Write(CR, 0x62);
00430     rtl8019Write(CPR, RXSTART_INIT);
00431     rtl8019Write(CR, 0x22);
00432     rtl8019Write(ISR, 0x10);
00433     rtl8019Write(TCR, TCR_INIT);
00434     
00435     <span class="keywordflow">if</span>(resend)
00436         rtl8019Write(CR, 0x26);
00437 
00438     rtl8019Write(ISR, 0xFF);
00439 }
00440 
00441 
00442 <span class="keywordtype">void</span> rtl8019RegDump(<span class="keywordtype">void</span>)
00443 {
00444 <span class="comment">//  unsigned char result;</span>
00445 <span class="comment">//  result = rtl8019Read(TR);</span>
00446     
00447 <span class="comment">//  rprintf("Media State: ");</span>
00448 <span class="comment">//  if(!(result &amp; AUTOD))</span>
00449 <span class="comment">//          rprintf("Autonegotiation\r\n");</span>
00450 <span class="comment">//  else if(result &amp; RST_B)</span>
00451 <span class="comment">//          rprintf("PHY in Reset   \r\n");</span>
00452 <span class="comment">//  else if(!(result &amp; RST_10B))</span>
00453 <span class="comment">//      rprintf("10BASE-T       \r\n");</span>
00454 <span class="comment">//  else if(!(result &amp; RST_TXB))</span>
00455 <span class="comment">//      rprintf("100BASE-T      \r\n");</span>
00456                 
00457     <span class="comment">//rprintf("TR regsiter      : %x\r\n",result);</span>
00458     <span class="comment">//result = read_mii(0x10,0);</span>
00459     <span class="comment">//rprintf("MII regsiter 0x10: %x\r\n",result);</span>
00460 
00461     rprintf(<span class="stringliteral">"Page0: CR  BNRY PSR PST ISR TSR RSR MMR TR  GPI\r\n"</span>);
00462     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"       "</span>);
00463     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(CR));
00464     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00465     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(BNRY));
00466     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"   "</span>);
00467     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(PSTART));
00468     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00469     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(PSTOP));
00470     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00471     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(ISR));
00472     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00473     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(TSR));
00474     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00475     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(RSR));
00476     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00477 <span class="comment">//  rprintfu08(rtl8019Read(MEMR));</span>
00478     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00479 <span class="comment">//  rprintfu08(rtl8019Read(TR));</span>
00480     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00481 <span class="comment">//  rprintfu08(rtl8019Read(GPI));</span>
00482     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00483 
00484     rtl8019Write(CR,rtl8019Read(CR)|PS0);
00485 
00486     rprintf(<span class="stringliteral">"Page1: CR  PAR    CPR\r\n"</span>);
00487     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"       "</span>);
00488     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(CR));
00489     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00490     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(rtl8019Read(PAR0));
00491     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(rtl8019Read(PAR1));
00492     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(rtl8019Read(PAR2));
00493     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(rtl8019Read(PAR3));
00494     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(rtl8019Read(PAR4));
00495     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(rtl8019Read(PAR5));
00496     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" "</span>);
00497     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(CPR));
00498     
00499     rtl8019Write(CR,rtl8019Read(CR)&amp;~PS0);
00500 
00501     delay_ms(25);
00502 }
00503 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Aug 22 04:29:27 2005 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
