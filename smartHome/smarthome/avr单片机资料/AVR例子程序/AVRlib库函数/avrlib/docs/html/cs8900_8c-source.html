<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: net/cs8900.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000001.html">net</a></div>
<h1>cs8900.c</h1><a href="cs8900_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file cs8900.c \brief Crystal CS8900 Ethernet Interface Driver. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'cs8900.c'</span>
00005 <span class="comment">// Title        : Crystal CS8900 Ethernet Interface Driver</span>
00006 <span class="comment">// Author       : Pascal Stang</span>
00007 <span class="comment">// Created      : 11/7/2004</span>
00008 <span class="comment">// Revised      : 11/7/2004</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : Atmel AVR series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">//*****************************************************************************</span>
00014 
00015 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00016 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00017 <span class="preprocessor">#include "<a class="code" href="rprintf_8h.html">rprintf.h</a>"</span>
00018 
00019 <span class="preprocessor">#include "<a class="code" href="cs8900_8h.html">cs8900.h</a>"</span>
00020 
00021 <span class="comment">// include configuration</span>
00022 <span class="preprocessor">#include "<a class="code" href="cs8900conf_8h.html">cs8900conf.h</a>"</span>
00023 
<a name="l00024"></a><a class="code" href="group__nic.html#ga0">00024</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga0">nicInit</a>(<span class="keywordtype">void</span>)
00025 {
00026     cs8900Init();
00027 }
00028 
<a name="l00029"></a><a class="code" href="group__nic.html#ga1">00029</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga1">nicSend</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* packet)
00030 {
00031     u08 timeout = 15;
00032 
00033     <span class="comment">// request space in CS8900's on-chip memory for storing an outgoing frame</span>
00034     cs8900Write16(CS8900_IO_TXCMD, TX_START_ALL_BYTES);
00035     cs8900Write16(CS8900_IO_TXLENGTH, len);
00036     <span class="comment">// check if CS8900 is ready to accept the frame we want to send</span>
00037     <span class="comment">// (timeout after 1.5ms since it should only take 1.25ms to</span>
00038     <span class="comment">//  finish sending previous frame.  If we timeout, it's probably</span>
00039     <span class="comment">//  because there's no link, no ethernet cable.)</span>
00040     <span class="keywordflow">while</span>(!(cs8900ReadReg(PP_BusST) &amp; READY_FOR_TX_NOW) &amp;&amp; timeout)
00041     {
00042         <span class="comment">// wait 100us</span>
00043         delay_us(100);
00044         timeout--;
00045     }
00046     <span class="comment">// write packet data bytes</span>
00047     cs8900CopyToFrame(packet, len);
00048 
00049     <span class="comment">// packet is automatically sent upon completion of above write</span>
00050 }
00051 
<a name="l00052"></a><a class="code" href="group__nic.html#ga2">00052</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="group__nic.html#ga2">nicPoll</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxlen, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* packet)
00053 {
00054     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packetLength;
00055 
00056     packetLength = cs8900BeginPacketRetreive();
00057 
00058     <span class="comment">// if there's no packet or an error - exit without ending the operation</span>
00059     <span class="keywordflow">if</span>( !packetLength )
00060         <span class="keywordflow">return</span> 0;
00061 
00062     <span class="comment">// drop anything too big for the buffer</span>
00063     <span class="keywordflow">if</span>( packetLength &gt; maxlen )
00064     {
00065         cs8900EndPacketRetreive();
00066         <span class="keywordflow">return</span> 0;
00067     }
00068     
00069     <span class="comment">// copy the packet data into the packet buffer</span>
00070     cs8900RetreivePacketData( packet, packetLength );
00071     cs8900EndPacketRetreive();
00072         
00073     <span class="keywordflow">return</span> packetLength;
00074 }
00075 
<a name="l00076"></a><a class="code" href="group__nic.html#ga3">00076</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga3">nicGetMacAddress</a>(u08* macaddr)
00077 {
00078     <span class="comment">// read MAC address registers</span>
00079     <span class="comment">// TODO: check byte order here!</span>
00080     *((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)(macaddr+0)) = cs8900ReadReg(PP_IA+0);
00081     *((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)(macaddr+2)) = cs8900ReadReg(PP_IA+2);
00082     *((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)(macaddr+4)) = cs8900ReadReg(PP_IA+4);
00083 }
00084 
00085 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cs8900BeginPacketRetreive(<span class="keywordtype">void</span>)
00086 {
00087     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> status;
00088 
00089     <span class="comment">// check RxEvent</span>
00090     status = cs8900ReadReg(PP_RxEvent);
00091 
00092     <span class="keywordflow">if</span>( !((status&amp;RX_OK)||(status&amp;RX_IA)||(status&amp;RX_BROADCAST)) )
00093     {
00094         <span class="keywordflow">return</span> 0;
00095     }
00096 
00097 <span class="comment">//  return cs8900ReadReg(PP_RxFrameByteCnt);</span>
00098     <span class="comment">// read RxStatus high-byte first</span>
00099     status =  cs8900Read(CS8900_IO_RXTX_DATA_PORT0+1)&lt;&lt;8;
00100     status |= cs8900Read(CS8900_IO_RXTX_DATA_PORT0+0);
00101     <span class="comment">// read packet length high-byte first</span>
00102     status =  cs8900Read(CS8900_IO_RXTX_DATA_PORT0+1)&lt;&lt;8;
00103     status |= cs8900Read(CS8900_IO_RXTX_DATA_PORT0+0);
00104 
00105     <span class="keywordflow">return</span> status;
00106 }
00107 
00108 <span class="keywordtype">void</span> cs8900RetreivePacketData(u08* packet, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packetLength )
00109 {
00110     cs8900CopyFromFrame(packet, packetLength);
00111 }
00112 
00113 <span class="keywordtype">void</span> cs8900EndPacketRetreive(<span class="keywordtype">void</span>)
00114 {
00115     <span class="comment">// dummy read first four bytes</span>
00116     <span class="comment">//cs8900CopyFromFrame(packet, 4);</span>
00117 }
00118 
00119 
00120 
00121 <span class="keywordtype">void</span> cs8900InitPorts(<span class="keywordtype">void</span>)
00122 {
00123 <span class="preprocessor">#if MEMORY_MAPPED_NIC == 1</span>
00124 <span class="preprocessor"></span>    <span class="comment">// enable external SRAM interface - no wait states</span>
00125     sbi(MCUSR, SRE);
00126 <span class="preprocessor">#else</span>
00127 <span class="preprocessor"></span>    <span class="comment">// set address port to output</span>
00128     outb(CS8900_ADDRESS_DDR, CS8900_ADDRESS_MASK);
00129     
00130     <span class="comment">// set data port to input with pull-ups</span>
00131     outb(CS8900_DATA_DDR, 0x00);
00132     outb(CS8900_DATA_PORT, 0xFF);
00133 
00134     <span class="comment">// initialize the control port read and write pins to de-asserted</span>
00135     sbi( CS8900_CONTROL_PORT, CS8900_CONTROL_READPIN );
00136     sbi( CS8900_CONTROL_PORT, CS8900_CONTROL_WRITEPIN );
00137     <span class="comment">// set the read and write pins to output</span>
00138     sbi( CS8900_CONTROL_DDR, CS8900_CONTROL_READPIN );
00139     sbi( CS8900_CONTROL_DDR, CS8900_CONTROL_WRITEPIN );
00140 <span class="preprocessor">#endif</span>
00141 <span class="preprocessor"></span>    <span class="comment">// set reset pin to output</span>
00142     sbi( CS8900_RESET_DDR, CS8900_RESET_PIN );
00143 }
00144 
00145 <span class="keywordtype">void</span> cs8900Init(<span class="keywordtype">void</span>)
00146 {
00147     cs8900InitPorts();
00148 
00149     <span class="comment">// assert hardware reset</span>
00150     sbi( CS8900_RESET_PORT, CS8900_RESET_PIN );
00151     <span class="comment">// wait</span>
00152     delay_ms(10);
00153     <span class="comment">// release hardware reset</span>
00154     cbi( CS8900_RESET_PORT, CS8900_RESET_PIN );
00155     delay_ms(10);
00156     
00157     <span class="comment">// Reset the Ethernet-Controller</span>
00158     cs8900Write16(CS8900_IO_PP_PTR, PP_SelfCTL);
00159     cs8900Write16(CS8900_IO_PP_DATA_PORT0, POWER_ON_RESET);
00160     <span class="comment">// wait until chip-reset is done</span>
00161     cs8900Write16(CS8900_IO_PP_PTR, PP_SelfST);
00162     <span class="keywordflow">while</span>(!(cs8900Read16(CS8900_IO_PP_DATA_PORT0) &amp; INIT_DONE));
00163 
00164     <span class="comment">// set our MAC as Individual Address</span>
00165     cs8900WriteReg(PP_IA+0, (CS8900_MAC1&lt;&lt;8) + CS8900_MAC0 );
00166     cs8900WriteReg(PP_IA+2, (CS8900_MAC3&lt;&lt;8) + CS8900_MAC2 );
00167     cs8900WriteReg(PP_IA+4, (CS8900_MAC5&lt;&lt;8) + CS8900_MAC4 );
00168     <span class="comment">// configure the Physical Interface</span>
00169     cs8900WriteReg(PP_LineCTL, SERIAL_RX_ON | SERIAL_TX_ON);
00170     cs8900WriteReg(PP_RxCTL, RX_OK_ACCEPT | RX_IA_ACCEPT | RX_BROADCAST_ACCEPT );
00171 }
00172 
00173 <span class="keywordtype">void</span> cs8900Write(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> address, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> data)
00174 {
00175     <span class="comment">// assert the address</span>
00176     outb(CS8900_ADDRESS_PORT, address | (inb(CS8900_ADDRESS_PORT)&amp;~CS8900_ADDRESS_MASK));
00177     <span class="comment">// set data bus as output</span>
00178     outb(CS8900_DATA_DDR, 0xFF);
00179     <span class="comment">// place data on bus</span>
00180     outb(CS8900_DATA_PORT, data);
00181     <span class="comment">// clock write pin</span>
00182     cbi(CS8900_CONTROL_PORT, CS8900_CONTROL_WRITEPIN);
00183     nop();
00184     nop();
00185     nop();
00186     nop();
00187     sbi(CS8900_CONTROL_PORT, CS8900_CONTROL_WRITEPIN);
00188     <span class="comment">// set data bus back to input with pullups enabled</span>
00189     outb(CS8900_DATA_DDR, 0x00);
00190     outb(CS8900_DATA_PORT, 0xFF);
00191 }
00192 
00193 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> cs8900Read(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> address)
00194 {
00195     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> data;
00196     <span class="comment">// assert the address</span>
00197     outb(CS8900_ADDRESS_PORT, address | (inb(CS8900_ADDRESS_PORT)&amp;~CS8900_ADDRESS_MASK));
00198     <span class="comment">// set data bus to input with pullups enabled</span>
00199     outb(CS8900_DATA_DDR, 0x00);
00200     outb(CS8900_DATA_PORT, 0xFF);
00201     <span class="comment">// assert read</span>
00202     cbi(CS8900_CONTROL_PORT, CS8900_CONTROL_READPIN);
00203     nop();
00204     nop();
00205     nop();
00206     nop();
00207     <span class="comment">// read in the data</span>
00208     data = inb( CS8900_DATA_PIN );
00209     <span class="comment">// negate read</span>
00210     sbi(CS8900_CONTROL_PORT, CS8900_CONTROL_READPIN);
00211     <span class="comment">// return data</span>
00212     <span class="keywordflow">return</span> data;
00213 }
00214 
00215 <span class="keywordtype">void</span> cs8900Write16(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> address, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> data)
00216 {
00217     cs8900Write(address+0, data);   
00218     cs8900Write(address+1, data&gt;&gt;8);    
00219 }
00220 
00221 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> cs8900Read16(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> address)
00222 {
00223     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> data;
00224     data =  cs8900Read(address+0);
00225     data |= cs8900Read(address+1)&lt;&lt;8;
00226     <span class="keywordflow">return</span> data;
00227 }
00228 
00229 <span class="comment">// writes a word in little-endian byte order to a specified PacketPage address</span>
00230 <span class="keywordtype">void</span> cs8900WriteReg(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> address, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> data)
00231 {
00232     cs8900Write16(CS8900_IO_PP_PTR, address);
00233     cs8900Write16(CS8900_IO_PP_DATA_PORT0, data);
00234 }
00235 
00236 <span class="comment">// reads a word in little-endian byte order from a specified PacketPage address</span>
00237 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> cs8900ReadReg(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> address)
00238 {
00239     cs8900Write16(CS8900_IO_PP_PTR, address);
00240     <span class="keywordflow">return</span> cs8900Read16(CS8900_IO_PP_DATA_PORT0);
00241 }
00242 
00243 <span class="comment">// copies bytes from MCU-memory to frame port</span>
00244 <span class="comment">// NOTES: * an odd number of byte may only be transfered</span>
00245 <span class="comment">//          if the frame is written to the end!</span>
00246 <span class="comment">//        * MCU-memory MUST start at word-boundary</span>
00247 
00248 <span class="keywordtype">void</span> cs8900CopyToFrame(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *source, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> size)
00249 {
00250     <span class="keywordflow">while</span>(size&gt;1)
00251     {
00252         cs8900Write16(CS8900_IO_RXTX_DATA_PORT0, *((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)source));
00253         source += 2;
00254         size -= 2;
00255     }
00256     <span class="comment">// if odd num. of bytes...</span>
00257     <span class="comment">// write leftover byte (the LAN-controller ignores the highbyte)</span>
00258     <span class="keywordflow">if</span>(size)
00259         cs8900Write16(CS8900_IO_RXTX_DATA_PORT0, *(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)source);
00260 }
00261 
00262 <span class="comment">// copies bytes from frame port to MCU-memory</span>
00263 <span class="comment">// NOTES: * an odd number of byte may only be transfered</span>
00264 <span class="comment">//          if the frame is read to the end!</span>
00265 <span class="comment">//        * MCU-memory MUST start at word-boundary</span>
00266 
00267 <span class="keywordtype">void</span> cs8900CopyFromFrame(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *dest, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> size)
00268 {
00269     <span class="keywordflow">while</span>(size&gt;1)
00270     {
00271         *((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> *)dest) = cs8900Read16(CS8900_IO_RXTX_DATA_PORT0);
00272         dest += 2;
00273         size -= 2;
00274     }
00275   
00276     <span class="comment">// check for leftover byte...</span>
00277     <span class="comment">// the LAN-Controller will return 0 for the highbyte</span>
00278     <span class="keywordflow">if</span>(size)    
00279         *(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)dest = cs8900Read16(CS8900_IO_RXTX_DATA_PORT0);
00280 }
00281 
00282 <span class="keywordtype">void</span> cs8900IORegDump(<span class="keywordtype">void</span>)
00283 {
00284     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"CS8900 I/O Registers\r\n"</span>);
00285     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" FRAME   ISQ  ADDR DATA0 DATA1\r\n"</span>);
00286     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"-------------------------------\r\n"</span>);
00287     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00288     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(cs8900Read16(CS8900_IO_RXTX_DATA_PORT0));
00289     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00290     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(cs8900Read16(CS8900_IO_ISQ));
00291     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00292     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(cs8900Read16(CS8900_IO_PP_PTR));
00293     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00294     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(cs8900Read16(CS8900_IO_PP_DATA_PORT0));
00295     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00296     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(cs8900Read16(CS8900_IO_PP_DATA_PORT1));
00297     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00298 }
00299 
00300 <span class="keywordtype">void</span> cs8900RegDump(<span class="keywordtype">void</span>)
00301 {
00302     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"CS8900 PacketPage Registers\r\n"</span>);
00303     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"CHIP ID: "</span>);
00304     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(cs8900ReadReg(PP_ChipID));
00305     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00306 
00307     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"PP_ISAIOB: "</span>);
00308     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(cs8900ReadReg(PP_ISAIOB));
00309     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00310 
00311     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"MAC addr: "</span>);
00312     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(cs8900ReadReg(PP_IA+0));
00313     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(cs8900ReadReg(PP_IA+2));
00314     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(cs8900ReadReg(PP_IA+4));
00315     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00316 }
00317 
<a name="l00318"></a><a class="code" href="group__nic.html#ga4">00318</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga4">nicRegDump</a>(<span class="keywordtype">void</span>)
00319 {
00320     cs8900IORegDump();
00321     cs8900RegDump();
00322 }
00323 
00324 
00325 u08 cs8900LinkStatus(<span class="keywordtype">void</span>)
00326 {
00327     <span class="keywordflow">if</span>(cs8900ReadReg(PP_LineST) &amp; LINK_OK)
00328         <span class="keywordflow">return</span> 1;
00329     <span class="keywordflow">else</span>
00330         <span class="keywordflow">return</span> 0;
00331 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Aug 22 04:29:27 2005 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
