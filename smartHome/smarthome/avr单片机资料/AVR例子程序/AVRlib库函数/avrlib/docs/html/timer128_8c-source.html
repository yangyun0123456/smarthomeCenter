<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: timer128.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>timer128.c</h1><a href="timer128_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file timer128.c \brief System Timer function library for Mega128. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'timer128.c'</span>
00005 <span class="comment">// Title        : System Timer function library for Mega128</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2000-2003</span>
00007 <span class="comment">// Created      : 11/22/2000</span>
00008 <span class="comment">// Revised      : 02/24/2003</span>
00009 <span class="comment">// Version      : 1.2</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#ifndef WIN32</span>
00019 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;avr/io.h&gt;</span>
00020 <span class="preprocessor">    #include &lt;avr/signal.h&gt;</span>
00021 <span class="preprocessor">    #include &lt;avr/interrupt.h&gt;</span>
00022 <span class="preprocessor">    #include &lt;avr/pgmspace.h&gt;</span>
00023 <span class="preprocessor">    #include &lt;avr/sleep.h&gt;</span>
00024 <span class="preprocessor">#endif</span>
00025 <span class="preprocessor"></span>
00026 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00027 <span class="preprocessor">#include "<a class="code" href="timer128_8h.html">timer128.h</a>"</span>
00028 
00029 <span class="comment">// Program ROM constants</span>
00030 <span class="comment">// the prescale division values stored in order of timer control register index</span>
00031 <span class="comment">// STOP, CLK, CLK/8, CLK/64, CLK/256, CLK/1024</span>
00032 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> __attribute__ ((progmem)) TimerPrescaleFactor[] = {0,1,8,64,256,1024};
00033 <span class="comment">// the prescale division values stored in order of timer control register index</span>
00034 <span class="comment">// STOP, CLK, CLK/8, CLK/32, CLK/64, CLK/128, CLK/256, CLK/1024</span>
00035 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> __attribute__ ((progmem)) TimerRTCPrescaleFactor[] = {0,1,8,32,64,128,256,1024};
00036 
00037 <span class="comment">// Global variables</span>
00038 <span class="comment">// time registers</span>
00039 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> TimerPauseReg;
00040 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer0Reg0;
00041 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer0Reg1;
00042 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer2Reg0;
00043 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer2Reg1;
00044 
00045 <span class="keyword">typedef</span> void (*voidFuncPtr)(void);
00046 <span class="keyword">volatile</span> <span class="keyword">static</span> voidFuncPtr TimerIntFunc[TIMER_NUM_INTERRUPTS];
00047 
00048 <span class="comment">// delay for a minimum of &lt;us&gt; microseconds </span>
00049 <span class="comment">// the time resolution is dependent on the time the loop takes </span>
00050 <span class="comment">// e.g. with 4Mhz and 5 cycles per loop, the resolution is 1.25 us </span>
00051 <span class="keywordtype">void</span> delay_us(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> time_us) 
00052 {
00053     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> delay_loops;
00054     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i;
00055 
00056     delay_loops = (time_us+3)/5*CYCLES_PER_US; <span class="comment">// +3 for rounding up (dirty) </span>
00057 
00058     <span class="comment">// one loop takes 5 cpu cycles </span>
00059     <span class="keywordflow">for</span> (i=0; i &lt; delay_loops; i++) {};
00060 }
00061 <span class="comment">/*</span>
00062 <span class="comment">void delay_ms(unsigned char time_ms)</span>
00063 <span class="comment">{</span>
00064 <span class="comment">    unsigned short delay_count = F_CPU / 4000;</span>
00065 <span class="comment"></span>
00066 <span class="comment">    unsigned short cnt;</span>
00067 <span class="comment">    asm volatile ("\n"</span>
00068 <span class="comment">                  "L_dl1%=:\n\t"</span>
00069 <span class="comment">                  "mov %A0, %A2\n\t"</span>
00070 <span class="comment">                  "mov %B0, %B2\n"</span>
00071 <span class="comment">                  "L_dl2%=:\n\t"</span>
00072 <span class="comment">                  "sbiw %A0, 1\n\t"</span>
00073 <span class="comment">                  "brne L_dl2%=\n\t"</span>
00074 <span class="comment">                  "dec %1\n\t" "brne L_dl1%=\n\t":"=&amp;w" (cnt)</span>
00075 <span class="comment">                  :"r"(time_ms), "r"((unsigned short) (delay_count))</span>
00076 <span class="comment">    );</span>
00077 <span class="comment">}</span>
00078 <span class="comment">*/</span>
<a name="l00079"></a><a class="code" href="group__timer.html#ga1">00079</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga1">timerInit</a>(<span class="keywordtype">void</span>)
00080 {
00081     u08 intNum;
00082     <span class="comment">// detach all user functions from interrupts</span>
00083     <span class="keywordflow">for</span>(intNum=0; intNum&lt;TIMER_NUM_INTERRUPTS; intNum++)
00084         <a class="code" href="group__timer.html#ga9">timerDetach</a>(intNum);
00085 
00086     <span class="comment">// initialize all timers</span>
00087     <a class="code" href="group__timer.html#ga2">timer0Init</a>();
00088     <a class="code" href="group__timer.html#ga3">timer1Init</a>();
00089     timer2Init();
00090     timer3Init();
00091     <span class="comment">// enable interrupts</span>
00092     sei();
00093 }
00094 
<a name="l00095"></a><a class="code" href="group__timer.html#ga2">00095</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga2">timer0Init</a>()
00096 {
00097     <span class="comment">// initialize timer 0</span>
00098     <a class="code" href="group__timer.html#ga4">timer0SetPrescaler</a>( <a class="code" href="group__timer.html#ga33">TIMER0PRESCALE</a> );   <span class="comment">// set prescaler</span>
00099     outb(TCNT0, 0);                         <span class="comment">// reset TCNT0</span>
00100     sbi(TIMSK, TOIE0);                      <span class="comment">// enable TCNT0 overflow interrupt</span>
00101 
00102     <a class="code" href="group__timer.html#ga11">timer0ClearOverflowCount</a>();             <span class="comment">// initialize time registers</span>
00103 }
00104 
<a name="l00105"></a><a class="code" href="group__timer.html#ga3">00105</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga3">timer1Init</a>(<span class="keywordtype">void</span>)
00106 {
00107     <span class="comment">// initialize timer 1</span>
00108     <a class="code" href="group__timer.html#ga6">timer1SetPrescaler</a>( <a class="code" href="group__timer.html#ga34">TIMER1PRESCALE</a> );   <span class="comment">// set prescaler</span>
00109     outb(TCNT1H, 0);                        <span class="comment">// reset TCNT1</span>
00110     outb(TCNT1L, 0);
00111     sbi(TIMSK, TOIE1);                      <span class="comment">// enable TCNT1 overflow</span>
00112 }
00113 
00114 <span class="keywordtype">void</span> timer2Init(<span class="keywordtype">void</span>)
00115 {
00116     <span class="comment">// initialize timer 2</span>
00117     <a class="code" href="group__timer128.html#ga8">timer2SetPrescaler</a>( <a class="code" href="group__timer.html#ga35">TIMER2PRESCALE</a> );   <span class="comment">// set prescaler</span>
00118     outb(TCNT2, 0);                         <span class="comment">// reset TCNT2</span>
00119     sbi(TIMSK, TOIE2);                      <span class="comment">// enable TCNT2 overflow</span>
00120 
00121     timer2ClearOverflowCount();             <span class="comment">// initialize time registers</span>
00122 }
00123 
00124 <span class="keywordtype">void</span> timer3Init(<span class="keywordtype">void</span>)
00125 {
00126     <span class="comment">// initialize timer 3</span>
00127     <a class="code" href="group__timer128.html#ga9">timer3SetPrescaler</a>( <a class="code" href="group__timer128.html#ga66">TIMER3PRESCALE</a> );   <span class="comment">// set prescaler</span>
00128     outb(TCNT3H, 0);                        <span class="comment">// reset TCNT3</span>
00129     outb(TCNT3L, 0);
00130     sbi(ETIMSK, TOIE3);                     <span class="comment">// enable TCNT3 overflow</span>
00131 }
00132 
<a name="l00133"></a><a class="code" href="group__timer.html#ga4">00133</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga4">timer0SetPrescaler</a>(u08 prescale)
00134 {
00135     <span class="comment">// set prescaler on timer 0</span>
00136     outb(TCCR0, (inb(TCCR0) &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00137 }
00138 
<a name="l00139"></a><a class="code" href="group__timer.html#ga6">00139</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga6">timer1SetPrescaler</a>(u08 prescale)
00140 {
00141     <span class="comment">// set prescaler on timer 1</span>
00142     outb(TCCR1B, (inb(TCCR1B) &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00143 }
00144 
<a name="l00145"></a><a class="code" href="group__timer128.html#ga8">00145</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga8">timer2SetPrescaler</a>(u08 prescale)
00146 {
00147     <span class="comment">// set prescaler on timer 2</span>
00148     outb(TCCR2, (inb(TCCR2) &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00149 }
00150 
<a name="l00151"></a><a class="code" href="group__timer128.html#ga9">00151</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga9">timer3SetPrescaler</a>(u08 prescale)
00152 {
00153     <span class="comment">// set prescaler on timer 2</span>
00154     outb(TCCR3B, (inb(TCCR3B) &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00155 }
00156 
<a name="l00157"></a><a class="code" href="group__timer.html#ga5">00157</a> u16 <a class="code" href="group__timer.html#ga5">timer0GetPrescaler</a>(<span class="keywordtype">void</span>)
00158 {
00159     <span class="comment">// get the current prescaler setting</span>
00160     <span class="keywordflow">return</span> (pgm_read_word(TimerPrescaleFactor+(inb(TCCR0) &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00161 }
00162 
<a name="l00163"></a><a class="code" href="group__timer.html#ga7">00163</a> u16 <a class="code" href="group__timer.html#ga7">timer1GetPrescaler</a>(<span class="keywordtype">void</span>)
00164 {
00165     <span class="comment">// get the current prescaler setting</span>
00166     <span class="keywordflow">return</span> (pgm_read_word(TimerPrescaleFactor+(inb(TCCR1B) &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00167 }
00168 
<a name="l00169"></a><a class="code" href="group__timer128.html#ga12">00169</a> u16 <a class="code" href="group__timer128.html#ga12">timer2GetPrescaler</a>(<span class="keywordtype">void</span>)
00170 {
00171     <span class="comment">// get the current prescaler setting</span>
00172     <span class="keywordflow">return</span> (pgm_read_word(TimerPrescaleFactor+(inb(TCCR2) &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00173 }
00174 
<a name="l00175"></a><a class="code" href="group__timer128.html#ga13">00175</a> u16 <a class="code" href="group__timer128.html#ga13">timer3GetPrescaler</a>(<span class="keywordtype">void</span>)
00176 {
00177     <span class="comment">// get the current prescaler setting</span>
00178     <span class="keywordflow">return</span> (pgm_read_word(TimerPrescaleFactor+(inb(TCCR3B) &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00179 }
00180 
<a name="l00181"></a><a class="code" href="group__timer.html#ga8">00181</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga8">timerAttach</a>(u08 interruptNum, <span class="keywordtype">void</span> (*userFunc)(<span class="keywordtype">void</span>) )
00182 {
00183     <span class="comment">// make sure the interrupt number is within bounds</span>
00184     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00185     {
00186         <span class="comment">// set the interrupt function to run</span>
00187         <span class="comment">// the supplied user's function</span>
00188         TimerIntFunc[interruptNum] = userFunc;
00189     }
00190 }
00191 
<a name="l00192"></a><a class="code" href="group__timer.html#ga9">00192</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga9">timerDetach</a>(u08 interruptNum)
00193 {
00194     <span class="comment">// make sure the interrupt number is within bounds</span>
00195     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00196     {
00197         <span class="comment">// set the interrupt function to run nothing</span>
00198         TimerIntFunc[interruptNum] = 0;
00199     }
00200 }
00201 
<a name="l00202"></a><a class="code" href="group__timer.html#ga10">00202</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga10">timerPause</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> pause_ms)
00203 {
00204     <span class="comment">// pauses for exactly &lt;pause_ms&gt; number of milliseconds</span>
00205     u08 timerThres;
00206     u32 ticRateHz;
00207     u32 pause;
00208 
00209     <span class="comment">// capture current pause timer value</span>
00210     timerThres = inb(TCNT2);
00211     <span class="comment">// reset pause timer overflow count</span>
00212     TimerPauseReg = 0;
00213     <span class="comment">// calculate delay for [pause_ms] milliseconds</span>
00214     <span class="comment">// prescaler division = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR2)))</span>
00215     ticRateHz = F_CPU/<a class="code" href="group__timer128.html#ga12">timer2GetPrescaler</a>();
00216     <span class="comment">// precision management</span>
00217     <span class="comment">// prevent overflow and precision underflow</span>
00218     <span class="comment">//  -could add more conditions to improve accuracy</span>
00219     <span class="keywordflow">if</span>( ((ticRateHz &lt; 429497) &amp;&amp; (pause_ms &lt;= 10000)) )
00220         pause = (pause_ms*ticRateHz)/1000;
00221     <span class="keywordflow">else</span>
00222         pause = pause_ms*(ticRateHz/1000);
00223     
00224     <span class="comment">// loop until time expires</span>
00225     <span class="keywordflow">while</span>( ((TimerPauseReg&lt;&lt;8) | inb(TCNT2)) &lt; (pause+timerThres) )
00226     {
00227         <span class="keywordflow">if</span>( TimerPauseReg &lt; (pause&gt;&gt;8));
00228         {
00229             <span class="comment">// save power by idling the processor</span>
00230             set_sleep_mode(SLEEP_MODE_IDLE);
00231             sleep_mode();
00232         }
00233     }
00234 }
00235 
<a name="l00236"></a><a class="code" href="group__timer.html#ga11">00236</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga11">timer0ClearOverflowCount</a>(<span class="keywordtype">void</span>)
00237 {
00238     <span class="comment">// clear the timer overflow counter registers</span>
00239     Timer0Reg0 = 0; <span class="comment">// initialize time registers</span>
00240     Timer0Reg1 = 0; <span class="comment">// initialize time registers</span>
00241 }
00242 
<a name="l00243"></a><a class="code" href="group__timer.html#ga12">00243</a> <span class="keywordtype">long</span> <a class="code" href="group__timer.html#ga12">timer0GetOverflowCount</a>(<span class="keywordtype">void</span>)
00244 {
00245     <span class="comment">// return the current timer overflow count</span>
00246     <span class="comment">// (this is since the last timer0ClearOverflowCount() command was called)</span>
00247     <span class="keywordflow">return</span> Timer0Reg0;
00248 }
00249 
00250 <span class="keywordtype">void</span> timer2ClearOverflowCount(<span class="keywordtype">void</span>)
00251 {
00252     <span class="comment">// clear the timer overflow counter registers</span>
00253     Timer2Reg0 = 0; <span class="comment">// initialize time registers</span>
00254     Timer2Reg1 = 0; <span class="comment">// initialize time registers</span>
00255 }
00256 
00257 <span class="keywordtype">long</span> timer2GetOverflowCount(<span class="keywordtype">void</span>)
00258 {
00259     <span class="comment">// return the current timer overflow count</span>
00260     <span class="comment">// (this is since the last timer2ClearOverflowCount() command was called)</span>
00261     <span class="keywordflow">return</span> Timer2Reg0;
00262 }
00263 
00264 
<a name="l00265"></a><a class="code" href="group__timerpwm.html#ga0">00265</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga0">timer1PWMInit</a>(u08 bitRes)
00266 {
00267     <span class="comment">// configures timer1 for use with PWM output</span>
00268     <span class="comment">// on pins OC1A, OC1B, and OC1C</span>
00269 
00270     <span class="comment">// enable Timer1 as 8,9,10bit PWM</span>
00271     <span class="keywordflow">if</span>(bitRes == 9)
00272     {   <span class="comment">// 9bit mode</span>
00273         sbi(TCCR1A,WGMA1);
00274         cbi(TCCR1A,WGMA0);
00275     }
00276     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( bitRes == 10 )
00277     {   <span class="comment">// 10bit mode</span>
00278         sbi(TCCR1A,WGMA1);
00279         sbi(TCCR1A,WGMA0);
00280     }
00281     <span class="keywordflow">else</span>
00282     {   <span class="comment">// default 8bit mode</span>
00283         cbi(TCCR1A,WGMA1);
00284         sbi(TCCR1A,WGMA0);
00285     }
00286 
00287     <span class="comment">// set clear-timer-on-compare-match</span>
00288     <span class="comment">//cbi(TCCR1B,CTC1);</span>
00289     <span class="comment">// clear output compare value A</span>
00290     outb(OCR1AH, 0);
00291     outb(OCR1AL, 0);
00292     <span class="comment">// clear output compare value B</span>
00293     outb(OCR1BH, 0);
00294     outb(OCR1BL, 0);
00295     <span class="comment">// clear output compare value C</span>
00296     outb(OCR1CH, 0);
00297     outb(OCR1CL, 0);
00298 }
00299 
<a name="l00300"></a><a class="code" href="group__timer128.html#ga22">00300</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga1">timer1PWMInitICR</a>(u16 topcount)
00301 {
00302     <span class="comment">// set PWM mode with ICR top-count</span>
00303     cbi(TCCR1A,WGM10);
00304     sbi(TCCR1A,WGM11);
00305     sbi(TCCR1B,WGM12);
00306     sbi(TCCR1B,WGM13);
00307     
00308     <span class="comment">// set top count value</span>
00309     ICR1H = (u08)(topcount&gt;&gt;8);
00310     ICR1L = (u08)topcount;
00311     
00312     <span class="comment">// clear output compare value A</span>
00313     outb(OCR1AH, 0);
00314     outb(OCR1AL, 0);
00315     <span class="comment">// clear output compare value B</span>
00316     outb(OCR1BH, 0);
00317     outb(OCR1BL, 0);
00318     <span class="comment">// clear output compare value C</span>
00319     outb(OCR1CH, 0);
00320     outb(OCR1CL, 0);
00321 }
00322 
<a name="l00323"></a><a class="code" href="group__timerpwm.html#ga2">00323</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga2">timer1PWMOff</a>(<span class="keywordtype">void</span>)
00324 {
00325     <span class="comment">// turn off PWM on Timer1</span>
00326     cbi(TCCR1A,WGMA1);
00327     cbi(TCCR1A,WGMA0);
00328     <span class="comment">// clear (disable) clear-timer-on-compare-match</span>
00329     <span class="comment">//cbi(TCCR1B,CTC1);</span>
00330     <span class="comment">// set PWM1A/B/C (OutputCompare action) to none</span>
00331     <a class="code" href="group__timerpwm.html#ga5">timer1PWMAOff</a>();
00332     <a class="code" href="group__timerpwm.html#ga6">timer1PWMBOff</a>();
00333     <a class="code" href="group__timer128.html#ga29">timer1PWMCOff</a>();
00334 }
00335 
<a name="l00336"></a><a class="code" href="group__timerpwm.html#ga3">00336</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga3">timer1PWMAOn</a>(<span class="keywordtype">void</span>)
00337 {
00338     <span class="comment">// turn on channel A (OC1A) PWM output</span>
00339     <span class="comment">// set OC1A as non-inverted PWM</span>
00340     sbi(TCCR1A,COMA1);
00341     cbi(TCCR1A,COMA0);
00342 }
00343 
<a name="l00344"></a><a class="code" href="group__timerpwm.html#ga4">00344</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga4">timer1PWMBOn</a>(<span class="keywordtype">void</span>)
00345 {
00346     <span class="comment">// turn on channel B (OC1B) PWM output</span>
00347     <span class="comment">// set OC1B as non-inverted PWM</span>
00348     sbi(TCCR1A,COMB1);
00349     cbi(TCCR1A,COMB0);
00350 }
00351 
<a name="l00352"></a><a class="code" href="group__timer128.html#ga26">00352</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga26">timer1PWMCOn</a>(<span class="keywordtype">void</span>)
00353 {
00354     <span class="comment">// turn on channel C (OC1C) PWM output</span>
00355     <span class="comment">// set OC1C as non-inverted PWM</span>
00356     sbi(TCCR1A,COMC1);
00357     cbi(TCCR1A,COMC0);
00358 }
00359 
<a name="l00360"></a><a class="code" href="group__timerpwm.html#ga5">00360</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga5">timer1PWMAOff</a>(<span class="keywordtype">void</span>)
00361 {
00362     <span class="comment">// turn off channel A (OC1A) PWM output</span>
00363     <span class="comment">// set OC1A (OutputCompare action) to none</span>
00364     cbi(TCCR1A,COMA1);
00365     cbi(TCCR1A,COMA0);
00366 }
00367 
<a name="l00368"></a><a class="code" href="group__timerpwm.html#ga6">00368</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga6">timer1PWMBOff</a>(<span class="keywordtype">void</span>)
00369 {
00370     <span class="comment">// turn off channel B (OC1B) PWM output</span>
00371     <span class="comment">// set OC1B (OutputCompare action) to none</span>
00372     cbi(TCCR1A,COMB1);
00373     cbi(TCCR1A,COMB0);
00374 }
00375 
<a name="l00376"></a><a class="code" href="group__timer128.html#ga29">00376</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga29">timer1PWMCOff</a>(<span class="keywordtype">void</span>)
00377 {
00378     <span class="comment">// turn off channel C (OC1C) PWM output</span>
00379     <span class="comment">// set OC1C (OutputCompare action) to none</span>
00380     cbi(TCCR1A,COMC1);
00381     cbi(TCCR1A,COMC0);
00382 }
00383 
<a name="l00384"></a><a class="code" href="group__timerpwm.html#ga7">00384</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga7">timer1PWMASet</a>(u16 pwmDuty)
00385 {
00386     <span class="comment">// set PWM (output compare) duty for channel A</span>
00387     <span class="comment">// this PWM output is generated on OC1A pin</span>
00388     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00389     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00390     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00391     outb(OCR1AH, (pwmDuty&gt;&gt;8));     <span class="comment">// set the high 8bits of OCR1A</span>
00392     outb(OCR1AL, (pwmDuty&amp;0x00FF)); <span class="comment">// set the low 8bits of OCR1A</span>
00393 }
00394 
<a name="l00395"></a><a class="code" href="group__timerpwm.html#ga8">00395</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga8">timer1PWMBSet</a>(u16 pwmDuty)
00396 {
00397     <span class="comment">// set PWM (output compare) duty for channel B</span>
00398     <span class="comment">// this PWM output is generated on OC1B pin</span>
00399     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00400     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00401     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00402     outb(OCR1BH, (pwmDuty&gt;&gt;8));     <span class="comment">// set the high 8bits of OCR1B</span>
00403     outb(OCR1BL, (pwmDuty&amp;0x00FF)); <span class="comment">// set the low 8bits of OCR1B</span>
00404 }
00405 
<a name="l00406"></a><a class="code" href="group__timer128.html#ga32">00406</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga32">timer1PWMCSet</a>(u16 pwmDuty)
00407 {
00408     <span class="comment">// set PWM (output compare) duty for channel C</span>
00409     <span class="comment">// this PWM output is generated on OC1C pin</span>
00410     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00411     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00412     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00413     outb(OCR1CH, (pwmDuty&gt;&gt;8));     <span class="comment">// set the high 8bits of OCR1C</span>
00414     outb(OCR1CL, (pwmDuty&amp;0x00FF)); <span class="comment">// set the low 8bits of OCR1C</span>
00415 }
00416 
00417 
<a name="l00418"></a><a class="code" href="group__timer128.html#ga33">00418</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga33">timer3PWMInit</a>(u08 bitRes)
00419 {
00420     <span class="comment">// configures timer1 for use with PWM output</span>
00421     <span class="comment">// on pins OC3A, OC3B, and OC3C</span>
00422 
00423     <span class="comment">// enable Timer3 as 8,9,10bit PWM</span>
00424     <span class="keywordflow">if</span>(bitRes == 9)
00425     {   <span class="comment">// 9bit mode</span>
00426         sbi(TCCR3A,WGMA1);
00427         cbi(TCCR3A,WGMA0);
00428     }
00429     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( bitRes == 10 )
00430     {   <span class="comment">// 10bit mode</span>
00431         sbi(TCCR3A,WGMA1);
00432         sbi(TCCR3A,WGMA0);
00433     }
00434     <span class="keywordflow">else</span>
00435     {   <span class="comment">// default 8bit mode</span>
00436         cbi(TCCR3A,WGMA1);
00437         sbi(TCCR3A,WGMA0);
00438     }
00439 
00440     <span class="comment">// set clear-timer-on-compare-match</span>
00441     <span class="comment">//cbi(TCCR3B,CTC1);</span>
00442     <span class="comment">// clear output compare value A</span>
00443     outb(OCR3AH, 0);
00444     outb(OCR3AL, 0);
00445     <span class="comment">// clear output compare value B</span>
00446     outb(OCR3BH, 0);
00447     outb(OCR3BL, 0);
00448     <span class="comment">// clear output compare value B</span>
00449     outb(OCR3CH, 0);
00450     outb(OCR3CL, 0);
00451 }
00452 
<a name="l00453"></a><a class="code" href="group__timer128.html#ga34">00453</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga34">timer3PWMInitICR</a>(u16 topcount)
00454 {
00455     <span class="comment">// set PWM mode with ICR top-count</span>
00456     cbi(TCCR3A,WGM30);
00457     sbi(TCCR3A,WGM31);
00458     sbi(TCCR3B,WGM32);
00459     sbi(TCCR3B,WGM33);
00460     
00461     <span class="comment">// set top count value</span>
00462     ICR3H = (u08)(topcount&gt;&gt;8);
00463     ICR3L = (u08)topcount;
00464     
00465     <span class="comment">// clear output compare value A</span>
00466     outb(OCR3AH, 0);
00467     outb(OCR3AL, 0);
00468     <span class="comment">// clear output compare value B</span>
00469     outb(OCR3BH, 0);
00470     outb(OCR3BL, 0);
00471     <span class="comment">// clear output compare value C</span>
00472     outb(OCR3CH, 0);
00473     outb(OCR3CL, 0);
00474 }
00475 
<a name="l00476"></a><a class="code" href="group__timer128.html#ga35">00476</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga35">timer3PWMOff</a>(<span class="keywordtype">void</span>)
00477 {
00478     <span class="comment">// turn off PWM mode on Timer3</span>
00479     cbi(TCCR3A,WGMA1);
00480     cbi(TCCR3A,WGMA0);
00481     <span class="comment">// clear (disable) clear-timer-on-compare-match</span>
00482     <span class="comment">//cbi(TCCR3B,CTC1);</span>
00483     <span class="comment">// set OC3A/B/C (OutputCompare action) to none</span>
00484     <a class="code" href="group__timer128.html#ga39">timer3PWMAOff</a>();
00485     <a class="code" href="group__timer128.html#ga40">timer3PWMBOff</a>();
00486     <a class="code" href="group__timer128.html#ga41">timer3PWMCOff</a>();
00487 }
00488 
<a name="l00489"></a><a class="code" href="group__timer128.html#ga36">00489</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga36">timer3PWMAOn</a>(<span class="keywordtype">void</span>)
00490 {
00491     <span class="comment">// turn on channel A (OC3A) PWM output</span>
00492     <span class="comment">// set OC3A as non-inverted PWM</span>
00493     sbi(TCCR3A,COMA1);
00494     cbi(TCCR3A,COMA0);
00495 }
00496 
<a name="l00497"></a><a class="code" href="group__timer128.html#ga37">00497</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga37">timer3PWMBOn</a>(<span class="keywordtype">void</span>)
00498 {
00499     <span class="comment">// turn on channel B (OC3B) PWM output</span>
00500     <span class="comment">// set OC3B as non-inverted PWM</span>
00501     sbi(TCCR3A,COMB1);
00502     cbi(TCCR3A,COMB0);
00503 }
00504 
<a name="l00505"></a><a class="code" href="group__timer128.html#ga38">00505</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga38">timer3PWMCOn</a>(<span class="keywordtype">void</span>)
00506 {
00507     <span class="comment">// turn on channel C (OC3C) PWM output</span>
00508     <span class="comment">// set OC3C as non-inverted PWM</span>
00509     sbi(TCCR3A,COMC1);
00510     cbi(TCCR3A,COMC0);
00511 }
00512 
<a name="l00513"></a><a class="code" href="group__timer128.html#ga39">00513</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga39">timer3PWMAOff</a>(<span class="keywordtype">void</span>)
00514 {
00515     <span class="comment">// turn off channel A (OC3A) PWM output</span>
00516     <span class="comment">// set OC3A (OutputCompare action) to none</span>
00517     cbi(TCCR3A,COMA1);
00518     cbi(TCCR3A,COMA0);
00519 }
00520 
<a name="l00521"></a><a class="code" href="group__timer128.html#ga40">00521</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga40">timer3PWMBOff</a>(<span class="keywordtype">void</span>)
00522 {
00523     <span class="comment">// turn off channel B (OC3B) PWM output</span>
00524     <span class="comment">// set OC3B (OutputCompare action) to none</span>
00525     cbi(TCCR3A,COMB1);
00526     cbi(TCCR3A,COMB0);
00527 }
00528 
<a name="l00529"></a><a class="code" href="group__timer128.html#ga41">00529</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga41">timer3PWMCOff</a>(<span class="keywordtype">void</span>)
00530 {
00531     <span class="comment">// turn off channel C (OC3C) PWM output</span>
00532     <span class="comment">// set OC3C (OutputCompare action) to none</span>
00533     cbi(TCCR3A,COMC1);
00534     cbi(TCCR3A,COMC0);
00535 }
00536 
<a name="l00537"></a><a class="code" href="group__timer128.html#ga42">00537</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga42">timer3PWMASet</a>(u16 pwmDuty)
00538 {
00539     <span class="comment">// set PWM (output compare) duty for channel A</span>
00540     <span class="comment">// this PWM output is generated on OC3A pin</span>
00541     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00542     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00543     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00544     outb(OCR3AH, (pwmDuty&gt;&gt;8));     <span class="comment">// set the high 8bits of OCR3A</span>
00545     outb(OCR3AL, (pwmDuty&amp;0x00FF)); <span class="comment">// set the low 8bits of OCR3A</span>
00546 }
00547 
<a name="l00548"></a><a class="code" href="group__timer128.html#ga43">00548</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga43">timer3PWMBSet</a>(u16 pwmDuty)
00549 {
00550     <span class="comment">// set PWM (output compare) duty for channel B</span>
00551     <span class="comment">// this PWM output is generated on OC3B pin</span>
00552     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00553     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00554     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00555     outb(OCR3BH, (pwmDuty&gt;&gt;8));     <span class="comment">// set the high 8bits of OCR3B</span>
00556     outb(OCR3BL, (pwmDuty&amp;0x00FF)); <span class="comment">// set the low 8bits of OCR3B</span>
00557 }
00558 
<a name="l00559"></a><a class="code" href="group__timer128.html#ga44">00559</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga44">timer3PWMCSet</a>(u16 pwmDuty)
00560 {
00561     <span class="comment">// set PWM (output compare) duty for channel B</span>
00562     <span class="comment">// this PWM output is generated on OC3C pin</span>
00563     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00564     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00565     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00566     outb(OCR3CH, (pwmDuty&gt;&gt;8));     <span class="comment">// set the high 8bits of OCR3C</span>
00567     outb(OCR3CL, (pwmDuty&amp;0x00FF)); <span class="comment">// set the low 8bits of OCR3C</span>
00568 }
00569 
00570 <span class="comment"></span>
00571 <span class="comment">//! Interrupt handler for tcnt0 overflow interrupt</span>
<a name="l00572"></a><a class="code" href="timer128_8c.html#a53">00572</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW0)
00573 {
00574     Timer0Reg0++;       <span class="comment">// increment low-order counter</span>
00575     <span class="keywordflow">if</span>(!Timer0Reg0)     <span class="comment">// if low-order counter rollover</span>
00576         Timer0Reg1++;   <span class="comment">// increment high-order counter </span>
00577 
00578     <span class="comment">// if a user function is defined, execute it too</span>
00579     <span class="keywordflow">if</span>(TimerIntFunc[TIMER0OVERFLOW_INT])
00580         TimerIntFunc[TIMER0OVERFLOW_INT]();
00581 }
00582 <span class="comment"></span>
00583 <span class="comment">//! Interrupt handler for Timer1 overflow interrupt</span>
<a name="l00584"></a><a class="code" href="timer128_8c.html#a54">00584</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW1)
00585 {
00586     <span class="comment">// if a user function is defined, execute it</span>
00587     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OVERFLOW_INT])
00588         TimerIntFunc[TIMER1OVERFLOW_INT]();
00589 }
00590 <span class="comment"></span>
00591 <span class="comment">//! Interrupt handler for Timer2 overflow interrupt</span>
<a name="l00592"></a><a class="code" href="timer128_8c.html#a55">00592</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW2)
00593 {
00594     Timer2Reg0++;       <span class="comment">// increment low-order counter</span>
00595     <span class="keywordflow">if</span>(!Timer2Reg0)     <span class="comment">// if low-order counter rollover</span>
00596         Timer2Reg1++;   <span class="comment">// increment high-order counter </span>
00597 
00598     <span class="comment">// increment pause counter</span>
00599     TimerPauseReg++;
00600 
00601     <span class="comment">// if a user function is defined, execute it</span>
00602     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OVERFLOW_INT])
00603         TimerIntFunc[TIMER2OVERFLOW_INT]();
00604 }
00605 <span class="comment"></span>
00606 <span class="comment">//! Interrupt handler for Timer3 overflow interrupt</span>
<a name="l00607"></a><a class="code" href="timer128_8c.html#a56">00607</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW3)
00608 {
00609     <span class="comment">// if a user function is defined, execute it</span>
00610     <span class="keywordflow">if</span>(TimerIntFunc[TIMER3OVERFLOW_INT])
00611         TimerIntFunc[TIMER3OVERFLOW_INT]();
00612 }
00613 <span class="comment"></span>
00614 <span class="comment">//! Interrupt handler for OutputCompare0 match (OC0) interrupt</span>
<a name="l00615"></a><a class="code" href="timer128_8c.html#a57">00615</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE0)
00616 {
00617     <span class="comment">// if a user function is defined, execute it</span>
00618     <span class="keywordflow">if</span>(TimerIntFunc[TIMER0OUTCOMPARE_INT])
00619         TimerIntFunc[TIMER0OUTCOMPARE_INT]();
00620 }
00621 <span class="comment"></span>
00622 <span class="comment">//! Interrupt handler for OutputCompare1A match (OC1A) interrupt</span>
<a name="l00623"></a><a class="code" href="timer128_8c.html#a58">00623</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1A)
00624 {
00625     <span class="comment">// if a user function is defined, execute it</span>
00626     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREA_INT])
00627         TimerIntFunc[TIMER1OUTCOMPAREA_INT]();
00628 }
00629 <span class="comment"></span>
00630 <span class="comment">//! Interrupt handler for OutputCompare1B match (OC1B) interrupt</span>
<a name="l00631"></a><a class="code" href="timer128_8c.html#a59">00631</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1B)
00632 {
00633     <span class="comment">// if a user function is defined, execute it</span>
00634     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREB_INT])
00635         TimerIntFunc[TIMER1OUTCOMPAREB_INT]();
00636 }
00637 <span class="comment"></span>
00638 <span class="comment">//! Interrupt handler for OutputCompare1C match (OC1C) interrupt</span>
<a name="l00639"></a><a class="code" href="timer128_8c.html#a60">00639</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1C)
00640 {
00641     <span class="comment">// if a user function is defined, execute it</span>
00642     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREC_INT])
00643         TimerIntFunc[TIMER1OUTCOMPAREC_INT]();
00644 }
00645 <span class="comment"></span>
00646 <span class="comment">//! Interrupt handler for InputCapture1(IC1) interrupt</span>
<a name="l00647"></a><a class="code" href="timer128_8c.html#a61">00647</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_INPUT_CAPTURE1)
00648 {
00649     <span class="comment">// if a user function is defined, execute it</span>
00650     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1INPUTCAPTURE_INT])
00651         TimerIntFunc[TIMER1INPUTCAPTURE_INT]();
00652 }
00653 <span class="comment"></span>
00654 <span class="comment">//! Interrupt handler for OutputCompare2 match (OC2) interrupt</span>
<a name="l00655"></a><a class="code" href="timer128_8c.html#a62">00655</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE2)
00656 {
00657     <span class="comment">// if a user function is defined, execute it</span>
00658     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OUTCOMPARE_INT])
00659         TimerIntFunc[TIMER2OUTCOMPARE_INT]();
00660 }
00661 <span class="comment"></span>
00662 <span class="comment">//! Interrupt handler for OutputCompare3A match (OC3A) interrupt</span>
<a name="l00663"></a><a class="code" href="timer128_8c.html#a63">00663</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE3A)
00664 {
00665     <span class="comment">// if a user function is defined, execute it</span>
00666     <span class="keywordflow">if</span>(TimerIntFunc[TIMER3OUTCOMPAREA_INT])
00667         TimerIntFunc[TIMER3OUTCOMPAREA_INT]();
00668 }
00669 <span class="comment"></span>
00670 <span class="comment">//! Interrupt handler for OutputCompare3B match (OC3B) interrupt</span>
<a name="l00671"></a><a class="code" href="timer128_8c.html#a64">00671</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE3B)
00672 {
00673     <span class="comment">// if a user function is defined, execute it</span>
00674     <span class="keywordflow">if</span>(TimerIntFunc[TIMER3OUTCOMPAREB_INT])
00675         TimerIntFunc[TIMER3OUTCOMPAREB_INT]();
00676 }
00677 <span class="comment"></span>
00678 <span class="comment">//! Interrupt handler for OutputCompare3C match (OC3C) interrupt</span>
<a name="l00679"></a><a class="code" href="timer128_8c.html#a65">00679</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE3C)
00680 {
00681     <span class="comment">// if a user function is defined, execute it</span>
00682     <span class="keywordflow">if</span>(TimerIntFunc[TIMER3OUTCOMPAREC_INT])
00683         TimerIntFunc[TIMER3OUTCOMPAREC_INT]();
00684 }
00685 <span class="comment"></span>
00686 <span class="comment">//! Interrupt handler for InputCapture3 (IC3) interrupt</span>
<a name="l00687"></a><a class="code" href="timer128_8c.html#a66">00687</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_INPUT_CAPTURE3)
00688 {
00689     <span class="comment">// if a user function is defined, execute it</span>
00690     <span class="keywordflow">if</span>(TimerIntFunc[TIMER3INPUTCAPTURE_INT])
00691         TimerIntFunc[TIMER3INPUTCAPTURE_INT]();
00692 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Aug 22 04:29:28 2005 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
