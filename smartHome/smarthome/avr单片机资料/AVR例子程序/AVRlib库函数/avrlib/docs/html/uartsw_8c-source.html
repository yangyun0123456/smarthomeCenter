<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: uartsw.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>uartsw.c</h1><a href="uartsw_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file uartsw.c \brief Software Interrupt-driven UART Driver. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'uartsw.c'</span>
00005 <span class="comment">// Title        : Software Interrupt-driven UART Driver</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2002-2004</span>
00007 <span class="comment">// Created      : 7/20/2002</span>
00008 <span class="comment">// Revised      : 4/27/2004</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series (intended for the ATmega16 and ATmega32)</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>
00019 <span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>
00020 <span class="preprocessor">#include &lt;avr/signal.h&gt;</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00023 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00024 <span class="preprocessor">#include "<a class="code" href="uartsw_8h.html">uartsw.h</a>"</span>
00025 
00026 <span class="comment">// Program ROM constants</span>
00027 
00028 <span class="comment">// Global variables</span>
00029 
00030 <span class="comment">// uartsw transmit status and data variables</span>
00031 <span class="keyword">static</span> <span class="keyword">volatile</span> u08 UartswTxBusy;
00032 <span class="keyword">static</span> <span class="keyword">volatile</span> u08 UartswTxData;
00033 <span class="keyword">static</span> <span class="keyword">volatile</span> u08 UartswTxBitNum;
00034 
00035 <span class="comment">// baud rate common to transmit and receive</span>
00036 <span class="keyword">static</span> <span class="keyword">volatile</span> u16 UartswBaudRateDiv;
00037 
00038 <span class="comment">// uartsw receive status and data variables</span>
00039 <span class="keyword">static</span> <span class="keyword">volatile</span> u08 UartswRxBusy;
00040 <span class="keyword">static</span> <span class="keyword">volatile</span> u08 UartswRxData;
00041 <span class="keyword">static</span> <span class="keyword">volatile</span> u08 UartswRxBitNum;
00042 <span class="comment">// receive buffer</span>
00043 <span class="keyword">static</span> <a class="code" href="structstruct__cBuffer.html">cBuffer</a> uartswRxBuffer;               <span class="comment">///&lt; uartsw receive buffer</span>
00044 <span class="comment"></span><span class="comment">// automatically allocate space in ram for each buffer</span>
00045 <span class="keyword">static</span> <span class="keywordtype">char</span> uartswRxData[<a class="code" href="uartsw2conf_8h.html#a0">UARTSW_RX_BUFFER_SIZE</a>];
00046 
00047 <span class="comment">// functions</span>
00048 <span class="comment"></span>
00049 <span class="comment">//! enable and initialize the software uart</span>
<a name="l00050"></a><a class="code" href="uartsw2_8h.html#a0">00050</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="uartsw_8c.html#a9">uartswInit</a>(<span class="keywordtype">void</span>)
00051 {
00052     <span class="comment">// initialize the buffers</span>
00053     <a class="code" href="uartsw_8c.html#a10">uartswInitBuffers</a>();
00054     <span class="comment">// initialize the ports</span>
00055     sbi(<a class="code" href="uartsw2conf_8h.html#a3">UARTSW_TX_DDR</a>, <a class="code" href="uartsw2conf_8h.html#a4">UARTSW_TX_PIN</a>);
00056     cbi(<a class="code" href="uartsw2conf_8h.html#a6">UARTSW_RX_DDR</a>, <a class="code" href="uartsw2conf_8h.html#a8">UARTSW_RX_PIN</a>);
00057     cbi(<a class="code" href="uartsw2conf_8h.html#a5">UARTSW_RX_PORT</a>, <a class="code" href="uartsw2conf_8h.html#a8">UARTSW_RX_PIN</a>);
00058     <span class="comment">// initialize baud rate</span>
00059     <a class="code" href="uartsw_8c.html#a12">uartswSetBaudRate</a>(9600);
00060 
00061     <span class="comment">// setup the transmitter</span>
00062     UartswTxBusy = FALSE;
00063     <span class="comment">// disable OC1A interrupt</span>
00064     cbi(TIMSK, OCIE1A);
00065     <span class="comment">// attach TxBit service routine to OC1A</span>
00066     <a class="code" href="group__timer.html#ga8">timerAttach</a>(TIMER1OUTCOMPAREA_INT, <a class="code" href="uartsw_8c.html#a16">uartswTxBitService</a>);
00067 
00068     <span class="comment">// setup the receiver</span>
00069     UartswRxBusy = FALSE;
00070     <span class="comment">// disable OC1B interrupt</span>
00071     cbi(TIMSK, OCIE1B);
00072     <span class="comment">// attach RxBit service routine to OC1B</span>
00073     <a class="code" href="group__timer.html#ga8">timerAttach</a>(TIMER1OUTCOMPAREB_INT, <a class="code" href="uartsw_8c.html#a17">uartswRxBitService</a>);
00074     <span class="comment">// attach RxBit service routine to ICP</span>
00075     <a class="code" href="group__timer.html#ga8">timerAttach</a>(TIMER1INPUTCAPTURE_INT, <a class="code" href="uartsw_8c.html#a17">uartswRxBitService</a>);
00076     <span class="comment">// trigger on rising edge</span>
00077     sbi(TCCR1B, ICES1);
00078     <span class="comment">// enable ICP interrupt</span>
00079     sbi(TIMSK, TICIE1);
00080 
00081     <span class="comment">// turn on interrupts</span>
00082     sei();
00083 }
00084 <span class="comment"></span>
00085 <span class="comment">//! create and initialize the uart buffers</span>
<a name="l00086"></a><a class="code" href="uartsw2_8h.html#a1">00086</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="uartsw_8c.html#a10">uartswInitBuffers</a>(<span class="keywordtype">void</span>)
00087 {
00088     <span class="comment">// initialize the UART receive buffer</span>
00089     <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;uartswRxBuffer, uartswRxData, <a class="code" href="uartsw2conf_8h.html#a0">UARTSW_RX_BUFFER_SIZE</a>);
00090 }
00091 <span class="comment"></span>
00092 <span class="comment">//! turns off software UART</span>
<a name="l00093"></a><a class="code" href="uartsw2_8h.html#a2">00093</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="uartsw_8c.html#a11">uartswOff</a>(<span class="keywordtype">void</span>)
00094 {
00095     <span class="comment">// disable interrupts</span>
00096     cbi(TIMSK, OCIE1A);
00097     cbi(TIMSK, OCIE1B);
00098     cbi(TIMSK, TICIE1);
00099     <span class="comment">// detach the service routines</span>
00100     <a class="code" href="group__timer.html#ga9">timerDetach</a>(TIMER1OUTCOMPAREA_INT);
00101     <a class="code" href="group__timer.html#ga9">timerDetach</a>(TIMER1OUTCOMPAREB_INT);
00102     <a class="code" href="group__timer.html#ga9">timerDetach</a>(TIMER1INPUTCAPTURE_INT);
00103 }
00104 
<a name="l00105"></a><a class="code" href="uartsw2_8h.html#a4">00105</a> <span class="keywordtype">void</span> <a class="code" href="uartsw_8c.html#a12">uartswSetBaudRate</a>(u32 baudrate)
00106 {
00107     <span class="comment">// set timer prescaler</span>
00108     <a class="code" href="group__timer.html#ga6">timer1SetPrescaler</a>(<a class="code" href="group__timer.html#ga16">TIMER_CLK_DIV1</a>);
00109     <span class="comment">// calculate division factor for requested baud rate, and set it</span>
00110     UartswBaudRateDiv = (u16)((F_CPU+(baudrate/2L))/(baudrate*1L));
00111 }
00112 <span class="comment"></span>
00113 <span class="comment">//! returns the receive buffer structure </span>
<a name="l00114"></a><a class="code" href="uartsw2_8h.html#a3">00114</a> <span class="comment"></span><a class="code" href="structstruct__cBuffer.html">cBuffer</a>* <a class="code" href="uartsw_8c.html#a13">uartswGetRxBuffer</a>(<span class="keywordtype">void</span>)
00115 {
00116     <span class="comment">// return rx buffer pointer</span>
00117     <span class="keywordflow">return</span> &amp;uartswRxBuffer;
00118 }
00119 
<a name="l00120"></a><a class="code" href="uartsw2_8h.html#a5">00120</a> <span class="keywordtype">void</span> <a class="code" href="uartsw_8c.html#a14">uartswSendByte</a>(u08 data)
00121 {
00122     <span class="comment">// wait until uart is ready</span>
00123     <span class="keywordflow">while</span>(UartswTxBusy);
00124     <span class="comment">// set busy flag</span>
00125     UartswTxBusy = TRUE;
00126     <span class="comment">// save data</span>
00127     UartswTxData = data;
00128     <span class="comment">// set number of bits (+1 for stop bit)</span>
00129     UartswTxBitNum = 9;
00130     
00131     <span class="comment">// set the start bit</span>
00132 <span class="preprocessor">    #ifdef UARTSW_INVERT</span>
00133 <span class="preprocessor"></span>    sbi(<a class="code" href="uartsw2conf_8h.html#a2">UARTSW_TX_PORT</a>, <a class="code" href="uartsw2conf_8h.html#a4">UARTSW_TX_PIN</a>);
00134 <span class="preprocessor">    #else</span>
00135 <span class="preprocessor"></span>    cbi(<a class="code" href="uartsw2conf_8h.html#a2">UARTSW_TX_PORT</a>, <a class="code" href="uartsw2conf_8h.html#a4">UARTSW_TX_PIN</a>);
00136 <span class="preprocessor">    #endif</span>
00137 <span class="preprocessor"></span>
00138     <span class="comment">// schedule the next bit</span>
00139     outw(OCR1A, inw(TCNT1) + UartswBaudRateDiv);
00140     <span class="comment">// enable OC1A interrupt</span>
00141     sbi(TIMSK, OCIE1A);
00142 }
00143 <span class="comment"></span>
00144 <span class="comment">//! gets a byte (if available) from the uart receive buffer</span>
<a name="l00145"></a><a class="code" href="uartsw2_8h.html#a6">00145</a> <span class="comment"></span>u08 <a class="code" href="uartsw_8c.html#a15">uartswReceiveByte</a>(u08* rxData)
00146 {
00147     <span class="comment">// make sure we have a receive buffer</span>
00148     <span class="keywordflow">if</span>(uartswRxBuffer.<a class="code" href="structstruct__cBuffer.html#o1">size</a>)
00149     {
00150         <span class="comment">// make sure we have data</span>
00151         <span class="keywordflow">if</span>(uartswRxBuffer.<a class="code" href="structstruct__cBuffer.html#o2">datalength</a>)
00152         {
00153             <span class="comment">// get byte from beginning of buffer</span>
00154             *rxData = <a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(&amp;uartswRxBuffer);
00155             <span class="keywordflow">return</span> TRUE;
00156         }
00157         <span class="keywordflow">else</span>
00158         {
00159             <span class="comment">// no data</span>
00160             <span class="keywordflow">return</span> FALSE;
00161         }
00162     }
00163     <span class="keywordflow">else</span>
00164     {
00165         <span class="comment">// no buffer</span>
00166         <span class="keywordflow">return</span> FALSE;
00167     }
00168 }
00169 
<a name="l00170"></a><a class="code" href="uartsw2_8h.html#a7">00170</a> <span class="keywordtype">void</span> <a class="code" href="uartsw_8c.html#a16">uartswTxBitService</a>(<span class="keywordtype">void</span>)
00171 {
00172     <span class="keywordflow">if</span>(UartswTxBitNum)
00173     {
00174         <span class="comment">// there are bits still waiting to be transmitted</span>
00175         <span class="keywordflow">if</span>(UartswTxBitNum &gt; 1)
00176         {
00177             <span class="comment">// transmit data bits (inverted, LSB first)</span>
00178 <span class="preprocessor">            #ifdef UARTSW_INVERT</span>
00179 <span class="preprocessor"></span>            <span class="keywordflow">if</span>( !(UartswTxData &amp; 0x01) )
00180 <span class="preprocessor">            #else</span>
00181 <span class="preprocessor"></span>            <span class="keywordflow">if</span>( (UartswTxData &amp; 0x01) )
00182 <span class="preprocessor">            #endif</span>
00183 <span class="preprocessor"></span>                sbi(<a class="code" href="uartsw2conf_8h.html#a2">UARTSW_TX_PORT</a>, <a class="code" href="uartsw2conf_8h.html#a4">UARTSW_TX_PIN</a>);
00184             <span class="keywordflow">else</span>
00185                 cbi(<a class="code" href="uartsw2conf_8h.html#a2">UARTSW_TX_PORT</a>, <a class="code" href="uartsw2conf_8h.html#a4">UARTSW_TX_PIN</a>);
00186             <span class="comment">// shift bits down</span>
00187             UartswTxData = UartswTxData&gt;&gt;1;
00188         }
00189         <span class="keywordflow">else</span>
00190         {
00191             <span class="comment">// transmit stop bit</span>
00192 <span class="preprocessor">            #ifdef UARTSW_INVERT</span>
00193 <span class="preprocessor"></span>            cbi(<a class="code" href="uartsw2conf_8h.html#a2">UARTSW_TX_PORT</a>, <a class="code" href="uartsw2conf_8h.html#a4">UARTSW_TX_PIN</a>);
00194 <span class="preprocessor">            #else</span>
00195 <span class="preprocessor"></span>            sbi(<a class="code" href="uartsw2conf_8h.html#a2">UARTSW_TX_PORT</a>, <a class="code" href="uartsw2conf_8h.html#a4">UARTSW_TX_PIN</a>);
00196 <span class="preprocessor">            #endif</span>
00197 <span class="preprocessor"></span>        }
00198         <span class="comment">// schedule the next bit</span>
00199         outw(OCR1A, inw(OCR1A) + UartswBaudRateDiv);
00200         <span class="comment">// count down</span>
00201         UartswTxBitNum--;
00202     }
00203     <span class="keywordflow">else</span>
00204     {
00205         <span class="comment">// transmission is done</span>
00206         <span class="comment">// clear busy flag</span>
00207         UartswTxBusy = FALSE;
00208     }
00209 }
00210 
<a name="l00211"></a><a class="code" href="uartsw2_8h.html#a8">00211</a> <span class="keywordtype">void</span> <a class="code" href="uartsw_8c.html#a17">uartswRxBitService</a>(<span class="keywordtype">void</span>)
00212 {
00213     <span class="comment">// this function runs on either:</span>
00214     <span class="comment">// - a rising edge interrupt</span>
00215     <span class="comment">// - OC1B</span>
00216     <span class="keywordflow">if</span>(!UartswRxBusy)
00217     {
00218         <span class="comment">// this is a start bit</span>
00219         <span class="comment">// disable ICP interrupt</span>
00220         cbi(TIMSK, TICIE1);
00221         <span class="comment">// schedule data bit sampling 1.5 bit periods from now</span>
00222         outw(OCR1B, inw(TCNT1) + UartswBaudRateDiv + UartswBaudRateDiv/2);
00223         <span class="comment">// clear OC1B interrupt flag</span>
00224         sbi(TIFR, OCF1B);
00225         <span class="comment">// enable OC1B interrupt</span>
00226         sbi(TIMSK, OCIE1B);
00227         <span class="comment">// set start bit flag</span>
00228         UartswRxBusy = TRUE;
00229         <span class="comment">// reset bit counter</span>
00230         UartswRxBitNum = 0;
00231         <span class="comment">// reset data</span>
00232         UartswRxData = 0;
00233     }
00234     <span class="keywordflow">else</span>
00235     {
00236         <span class="comment">// start bit has already been received</span>
00237         <span class="comment">// we're in the data bits</span>
00238         
00239         <span class="comment">// shift data byte to make room for new bit</span>
00240         UartswRxData = UartswRxData&gt;&gt;1;
00241 
00242         <span class="comment">// sample the data line</span>
00243 <span class="preprocessor">        #ifdef UARTSW_INVERT</span>
00244 <span class="preprocessor"></span>        <span class="keywordflow">if</span>( !(inb(<a class="code" href="uartsw2conf_8h.html#a7">UARTSW_RX_PORTIN</a>) &amp; (1&lt;&lt;<a class="code" href="uartsw2conf_8h.html#a8">UARTSW_RX_PIN</a>)) )
00245 <span class="preprocessor">        #else</span>
00246 <span class="preprocessor"></span>        <span class="keywordflow">if</span>( !(inb(<a class="code" href="uartsw2conf_8h.html#a7">UARTSW_RX_PORTIN</a>) &amp; (1&lt;&lt;<a class="code" href="uartsw2conf_8h.html#a8">UARTSW_RX_PIN</a>)) )
00247 <span class="preprocessor">        #endif</span>
00248 <span class="preprocessor"></span>        {
00249             <span class="comment">// serial line is marking</span>
00250             <span class="comment">// record '1' bit</span>
00251             UartswRxData |= 0x80;
00252         }
00253 
00254         <span class="comment">// increment bit counter</span>
00255         UartswRxBitNum++;
00256         <span class="comment">// schedule next bit sample</span>
00257         outw(OCR1B, inw(OCR1B) + UartswBaudRateDiv);
00258 
00259         <span class="comment">// check if we have a full byte</span>
00260         <span class="keywordflow">if</span>(UartswRxBitNum &gt;= 8)
00261         {
00262             <span class="comment">// save data in receive buffer</span>
00263             <a class="code" href="group__buffer.html#ga5">bufferAddToEnd</a>(&amp;uartswRxBuffer, UartswRxData);
00264             <span class="comment">// disable OC1B interrupt</span>
00265             cbi(TIMSK, OCIE1B);
00266             <span class="comment">// clear ICP interrupt flag</span>
00267             sbi(TIFR, ICF1);
00268             <span class="comment">// enable ICP interrupt</span>
00269             sbi(TIMSK, TICIE1);
00270             <span class="comment">// clear start bit flag</span>
00271             UartswRxBusy = FALSE;
00272         }
00273     }
00274 }
00275 
00276 <span class="comment">/*</span>
00277 <span class="comment">void uartswRxBitService(void)</span>
00278 <span class="comment">{</span>
00279 <span class="comment">    u16 thisBitTime;</span>
00280 <span class="comment">    u08 bitperiods;</span>
00281 <span class="comment">    u08 i;</span>
00282 <span class="comment"></span>
00283 <span class="comment">    // bit transition was detected</span>
00284 <span class="comment">    // record bit's edge time</span>
00285 <span class="comment">    thisBitTime = inw(ICR1);</span>
00286 <span class="comment"></span>
00287 <span class="comment">    cbi(PORTB, 0);</span>
00288 <span class="comment"></span>
00289 <span class="comment">    if(!UartswRxStartBit)</span>
00290 <span class="comment">    {</span>
00291 <span class="comment">        // this is a start bit</span>
00292 <span class="comment">        // switch to falling-edge trigger</span>
00293 <span class="comment">        cbi(TCCR1B, ICES1);</span>
00294 <span class="comment">        // record bit time</span>
00295 <span class="comment">        UartswRxBitTime = thisBitTime;</span>
00296 <span class="comment">        // set start bit flag</span>
00297 <span class="comment">        UartswRxStartBit = TRUE;</span>
00298 <span class="comment">        // reset bit counter</span>
00299 <span class="comment">        UartswRxBitNum = 0;</span>
00300 <span class="comment">        // reset data</span>
00301 <span class="comment">        UartswRxData = 0;</span>
00302 <span class="comment">    }</span>
00303 <span class="comment">    else</span>
00304 <span class="comment">    {</span>
00305 <span class="comment">        // start bit has already been received</span>
00306 <span class="comment">        // we're in the data bits</span>
00307 <span class="comment">        </span>
00308 <span class="comment">        // how many bit periods since last edge?</span>
00309 <span class="comment">        bitperiods = (thisBitTime - UartswRxBitTime + UartswBaudRateDiv/2)/UartswBaudRateDiv;</span>
00310 <span class="comment">        // set last edge time</span>
00311 <span class="comment">        UartswRxBitTime = thisBitTime;</span>
00312 <span class="comment"></span>
00313 <span class="comment">        if(bitperiods &gt; 10)</span>
00314 <span class="comment">        {</span>
00315 <span class="comment">            // switch to trigger on rising edge</span>
00316 <span class="comment">            sbi(TCCR1B, ICES1);</span>
00317 <span class="comment">            // clear start bit flag</span>
00318 <span class="comment">            UartswRxStartBit = FALSE;</span>
00319 <span class="comment">        }</span>
00320 <span class="comment">        else</span>
00321 <span class="comment">        {</span>
00322 <span class="comment"></span>
00323 <span class="comment"></span>
00324 <span class="comment">        if( inb(TCCR1B) &amp; (1&lt;&lt;ICES1) )</span>
00325 <span class="comment">        {</span>
00326 <span class="comment">            // just triggered on a rising edge</span>
00327 <span class="comment">            // previous bits were zero</span>
00328 <span class="comment">            // shift in the data (data bits are inverted)</span>
00329 <span class="comment">            for(i=0; i&lt;bitperiods; i++)</span>
00330 <span class="comment">            {</span>
00331 <span class="comment">                UartswRxData = UartswRxData&lt;&lt;1;</span>
00332 <span class="comment">                UartswRxData |= 0x01;</span>
00333 <span class="comment">            }</span>
00334 <span class="comment">            // switch to trigger on falling edge</span>
00335 <span class="comment">            cbi(TCCR1B, ICES1);</span>
00336 <span class="comment">        }</span>
00337 <span class="comment">        else</span>
00338 <span class="comment">        {</span>
00339 <span class="comment">            // just triggered on a falling edge</span>
00340 <span class="comment">            // previous bits were one</span>
00341 <span class="comment">            // shift in the data (data bits are inverted)</span>
00342 <span class="comment">            for(i=0; i&lt;bitperiods; i++)</span>
00343 <span class="comment">            {</span>
00344 <span class="comment">                UartswRxData = UartswRxData&lt;&lt;1;</span>
00345 <span class="comment">            }</span>
00346 <span class="comment">            // switch to trigger on rising edge</span>
00347 <span class="comment">            sbi(TCCR1B, ICES1);</span>
00348 <span class="comment">        }</span>
00349 <span class="comment">        </span>
00350 <span class="comment">        // increment bit counter</span>
00351 <span class="comment">        UartswRxBitNum += bitperiods;</span>
00352 <span class="comment">        </span>
00353 <span class="comment">        // check if we have a full byte + start bit</span>
00354 <span class="comment">        if(bitperiods &gt; 8)</span>
00355 <span class="comment">        {</span>
00356 <span class="comment">            // save data in receive buffer</span>
00357 <span class="comment">            bufferAddToEnd(&amp;uartswRxBuffer, UartswRxData);</span>
00358 <span class="comment">            // switch to trigger on rising edge</span>
00359 <span class="comment">            sbi(TCCR1B, ICES1);</span>
00360 <span class="comment">            // clear start bit flag</span>
00361 <span class="comment">            UartswRxStartBit = FALSE;</span>
00362 <span class="comment">        }</span>
00363 <span class="comment">        }</span>
00364 <span class="comment">    }</span>
00365 <span class="comment"></span>
00366 <span class="comment">    // turn off debug LEDs</span>
00367 <span class="comment">    delay(10);</span>
00368 <span class="comment">    sbi(PORTB, 0);</span>
00369 <span class="comment">    sbi(PORTB, 1);</span>
00370 <span class="comment">}</span>
00371 <span class="comment">*/</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Aug 22 04:29:28 2005 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
